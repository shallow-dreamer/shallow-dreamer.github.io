---
layout:     post
title:      "训练过程记录"
subtitle:   ""
date:       2025-07-21
author:     " Shallow Dreamer"
header-img: "img/post-bg-js-version.jpg"
tags:
    - 训练记录
---

你提出的这个需求非常清晰，而且很实用，属于一种**分段线性采样策略**，我们可以称它为：

------

## ✅ **「分段精度采样（Piecewise Linear Sampling）」策略**

### 📌 核心目标

- **在训练轮次较小时（如 <1000）**，**记录全部数据**；
- **当训练轮次较大时（如 >100000）**，**线性间隔采样**；
- 总记录条数保持在合理范围，如 2000~10000；
- **无需提前知道总轮次**，**动态地适应轮次数量级**；
- 保证重要的训练阶段（如前期）**记录更细致**。

------

## ✅ 策略设计（分段采样）

| 轮次数量级         | 采样策略           |
| ------------------ | ------------------ |
| 1 ~ 1000           | **全记录**         |
| 1000 ~ 10000       | 每 10 步记录一次   |
| 10000 ~ 100000     | 每 50 步记录一次   |
| 100000 ~ 1000000   | 每 200 步记录一次  |
| 1000000 ~ 10000000 | 每 1000 步记录一次 |

这样你可以兼容：

- 少量轮次的详细调试；
- 大量训练的压缩记录。

------

## ✅ 统一适配的记录器实现（含详细注释）

```python
import time
from collections import defaultdict

class PiecewiseMetricsRecorder:
    def __init__(self, mode='step'):
        """
        分段采样策略记录器，自动适应训练长度，兼顾精度与性能
        :param mode: 'step' 或 'epoch'，决定记录依据
        """
        assert mode in ('step', 'epoch')
        self.mode = mode
        self.records = defaultdict(list)
        self._step = 0
        self._epoch = 0

    def step(self):
        """每训练一步后调用，更新计数器"""
        self._step += 1

    def epoch(self):
        """每轮结束后调用，更新计数器"""
        self._epoch += 1

    def record(self, metrics: dict):
        """
        记录指标（根据当前采样规则决定是否保留）
        :param metrics: 字典形式指标，例如 {'loss': 0.234, 'acc': 0.9}
        """
        key = self._step if self.mode == 'step' else self._epoch

        if not self._should_sample(key):
            return

        ts = time.time()
        for k, v in metrics.items():
            self.records[k].append((key, float(v), ts))

    def _should_sample(self, key: int) -> bool:
        """
        分段采样策略核心逻辑，根据 key（step 或 epoch）判断是否采样
        """
        if key < 1000:
            return True                # 小于1000，全记录
        elif key < 10000:
            return key % 10 == 0       # 每10步记录一次
        elif key < 100000:
            return key % 50 == 0       # 每50步记录一次
        elif key < 1000000:
            return key % 200 == 0      # 每200步记录一次
        else:
            return key % 1000 == 0     # 每1000步记录一次

    def get_all(self, as_dict=True):
        """
        返回所有记录数据
        :param as_dict: 是否以 dict 格式返回（否则返回 DataFrame）
        """
        if as_dict:
            return dict(self.records)
        else:
            import pandas as pd
            rows = []
            for metric, values in self.records.items():
                for key, value, ts in values:
                    rows.append({
                        'metric': metric,
                        self.mode: key,
                        'value': value,
                        'timestamp': ts
                    })
            return pd.DataFrame(rows)
```

------

## ✅ 使用方法（和你现在训练流程对接非常简单）

```python
recorder = PiecewiseMetricsRecorder(mode='step')

for epoch in range(num_epochs):
    recorder.epoch()
    for step, (x, y) in enumerate(train_loader):
        recorder.step()

        loss = ...
        acc = ...
        lr = ...

        recorder.record({
            'loss': loss.item(),
            'acc': acc,
            'lr': lr
        })

# 获取记录数据
records = recorder.get_all()  # dict
# 或者 records_df = recorder.get_all(as_dict=False)
```

------

## ✅ 输出示例

假设你训练了 200000 步：

| step   | loss | acc   |
| ------ | ---- | ----- |
| 0      | 1.23 | 0.55  |
| 1      | 1.12 | 0.60  |
| ...    | ...  | ...   |
| 1000   | 0.90 | 0.75  |
| 1010   | 0.87 | 0.76  |
| 1050   | 0.85 | 0.78  |
| 1100   | ...  | ...   |
| ...    | ...  | ...   |
| 200000 | 0.02 | 0.999 |

------

## ✅ 优点总结

| 优点                  | 描述                         |
| --------------------- | ---------------------------- |
| 🔁 自动适应轮次数量级  | 无需预知训练总长度           |
| 📊 保留细节 & 控制规模 | 小训练保留全部，大训练精简   |
| ⚡ 高性能无依赖        | 无外部依赖，记录逻辑轻量快速 |
| 🧩 容易扩展            | 可添加保存、分析、图表功能   |

------

## ✅ 如你还有这些需求，我可继续扩展：

- 保存为 JSON、CSV、Parquet 文件；
- 添加分组记录（多模型/多阶段）；
- 实时绘图（matplotlib）；
- 记录某些指标变化率（如 loss delta）；

是否需要我给你整合一个训练器封装类，把这个记录器直接挂进去？或者你是否想让它支持 `validation loss`、`测试指标` 等统一入口？我可以帮你设计。
