---
layout:     post
title:      "仿真任务组合生成"
subtitle:   ""
date:       2025-11-10
author:     " Shallow Dreamer"
header-img: "img/post-bg-js-version.jpg"
tags:
    - python
    - pathlib
---

## 我的提问：

在使用Path进行文件遍历的时候是否可以设置以某一种文件信息方案进行排序获取

---

## ChatGPT 回答：

可以。  
Python 的 `pathlib.Path` 自身在遍历（如 `iterdir()`、`glob()`、`rglob()`）时**不会自动排序**，但你完全可以在遍历结果基础上**按任意文件信息方案进行排序**。

* * *

### ✅ 常见的排序方式

下面是几种常见的可选排序方案。

#### 1\. 按文件名排序

    from pathlib import Path
    
    p = Path("/path/to/dir")
    files = sorted(p.iterdir(), key=lambda f: f.name)


#### 2\. 按修改时间排序

    files = sorted(p.iterdir(), key=lambda f: f.stat().st_mtime)


*   `st_mtime`：最后修改时间
    
*   `st_ctime`：创建时间（Windows）或元数据更改时间（Unix）
    

#### 3\. 按文件大小排序

    files = sorted(p.iterdir(), key=lambda f: f.stat().st_size)


#### 4\. 按扩展名排序

    files = sorted(p.iterdir(), key=lambda f: f.suffix)


#### 5\. 组合排序（例如先按扩展名，再按文件名）

    files = sorted(p.iterdir(), key=lambda f: (f.suffix, f.name))


#### 6\. 按自定义函数排序（例如文件名中的数字）

    import re
    files = sorted(p.iterdir(), key=lambda f: int(re.search(r'\d+', f.stem).group()) if re.search(r'\d+', f.stem) else 0)


* * *

### ✅ 深度遍历（递归）

`rglob('*')` 同样适用：

    files = sorted(p.rglob("*.txt"), key=lambda f: f.stat().st_mtime)


* * *

### ✅ 性能建议

*   如果目录中文件非常多（上万级别），调用 `f.stat()` 会触发大量系统调用 → 可考虑：
    
    *   **先缓存 stat 结果**（比如用一次性列表推导）；
        
    *   或者只按文件名、扩展名等字符串属性排序；
        
    *   或者使用 `os.scandir()`（它返回的 `DirEntry` 对象能更高效地访问 `.stat()`）。
        

示例（高性能版）：

    import os
    from pathlib import Path
    
    p = Path("/path/to/dir")
    with os.scandir(p) as it:
        entries = [entry for entry in it if entry.is_file()]
    files = sorted(entries, key=lambda e: e.stat().st_mtime)


* * *

### ✅ 小结

| 需求 | 方案 |
| --- | --- |
| 文件名 | `key=lambda f: f.name` |
| 修改时间 | `key=lambda f: f.stat().st_mtime` |
| 文件大小 | `key=lambda f: f.stat().st_size` |
| 扩展名 | `key=lambda f: f.suffix` |
| 自定义逻辑 | `key=自定义函数` |
| 提升性能 | 使用 `os.scandir()` 缓存 stat |

* * *

是否希望我帮你封装一个通用的 `list_files(path, sort_by="name", reverse=False)` 函数，可以传入排序方式字符串（如 `"mtime"`、`"size"`、`"suffix"`）自动返回排序结果？

---

## 我的提问：

需要，还有就是尽可能提升性能

---

## ChatGPT 回答：

非常好 👍  
下面给你一个 **高性能 + 灵活排序** 的 `list_files()` 函数实现：

*   支持多种排序方式：`name`、`mtime`、`ctime`、`size`、`suffix`、`custom`
    
*   使用 `os.scandir()` 提升性能（比 `Path.iterdir()` 快约 2～5 倍）
    
*   支持递归（`recursive=True`）
    
*   支持反向排序（`reverse=True`）
    
*   支持传入自定义排序函数
    
* * *

✅ 高性能文件遍历与排序函数
--------------

    import os
    from pathlib import Path
    from typing import Callable, Iterable, List, Union
    
    def list_files(
        path: Union[str, Path],
        sort_by: str = "name",
        reverse: bool = False,
        recursive: bool = False,
        custom_key: Callable[[os.DirEntry], any] = None,
        include_dirs: bool = False,
    ) -> List[Path]:
        """
        高性能文件遍历与排序。
    
        参数：
            path (str|Path): 要遍历的目录
            sort_by (str): 排序方式，可选：
                - "name": 文件名
                - "size": 文件大小
                - "mtime": 修改时间
                - "ctime": 创建时间
                - "suffix": 扩展名
                - "custom": 使用自定义函数
            reverse (bool): 是否倒序
            recursive (bool): 是否递归遍历子目录
            custom_key (Callable): sort_by="custom" 时的排序函数
            include_dirs (bool): 是否包含目录（默认只返回文件）
        
        返回：
            List[Path]: 排序后的 Path 列表
        """
        path = Path(path)
        if not path.is_dir():
            raise NotADirectoryError(f"{path} is not a directory")
    
        def _scan(directory: Path) -> Iterable[os.DirEntry]:
            with os.scandir(directory) as it:
                for entry in it:
                    if entry.is_dir(follow_symlinks=False):
                        if include_dirs:
                            yield entry
                        if recursive:
                            yield from _scan(Path(entry.path))
                    else:
                        yield entry
    
        # 收集文件
        entries = list(_scan(path))
    
        # 选择排序 key
        if sort_by == "name":
            key_func = lambda e: e.name.lower()
        elif sort_by == "size":
            key_func = lambda e: e.stat().st_size
        elif sort_by == "mtime":
            key_func = lambda e: e.stat().st_mtime
        elif sort_by == "ctime":
            key_func = lambda e: e.stat().st_ctime
        elif sort_by == "suffix":
            key_func = lambda e: Path(e.name).suffix
        elif sort_by == "custom" and custom_key:
            key_func = custom_key
        else:
            raise ValueError(f"Invalid sort_by value: {sort_by}")
    
        # 排序并返回 Path 对象
        return [Path(e.path) for e in sorted(entries, key=key_func, reverse=reverse)]


* * *

✅ 使用示例
------

### 按文件名排序

    files = list_files("/data", sort_by="name")


### 按修改时间倒序

    files = list_files("/data", sort_by="mtime", reverse=True)


### 递归遍历所有子目录

    files = list_files("/data", sort_by="size", recursive=True)


### 使用自定义排序函数

例如：按文件名中的数字排序

    import re
    
    def numeric_sort(e):
        m = re.search(r'\d+', e.name)
        return int(m.group()) if m else 0
    
    files = list_files("/data", sort_by="custom", custom_key=numeric_sort)


* * *

✅ 性能说明
------

*   使用 `os.scandir()` 而非 `Path.iterdir()` → 减少 `stat()` 系统调用
    
*   只在排序时才真正访问 `stat()` → 避免不必要的文件信息读取
    
*   `recursive=True` 使用生成器递归，不会造成栈溢出
    
* * *

是否希望我加一个 **分页支持（limit/offset）** 参数？这样你在前端或接口里可以轻松做大目录的分页浏览（避免一次加载上千文件）。

---

## 我的提问：

那使用Path.iterdir()时怎么实现，并尽可能优化性能，其次文件的信息在不同的平台上的含义是否相同

---

## ChatGPT 回答：

非常好的两个问题 👏，我们来分两部分讲清楚：

* * *

🧩 一、使用 `Path.iterdir()` 的实现与性能优化
---------------------------------

### ✅ 基本思路

`Path.iterdir()` 返回的是 `Path` 对象迭代器，使用方便、直观、可与 `pathlib` API 配合，但性能比 `os.scandir()` 略低（因为会多做一层封装和系统调用）。

你仍可以用 `sorted()` + `Path.stat()` 等方式实现排序，但如果不加优化，在大目录下会明显变慢。

* * *

### ✅ 优化版实现

    from pathlib import Path
    from typing import Callable, List, Union
    
    def list_files_pathlib(
        path: Union[str, Path],
        sort_by: str = "name",
        reverse: bool = False,
        recursive: bool = False,
        include_dirs: bool = False,
        custom_key: Callable[[Path], any] = None,
    ) -> List[Path]:
        """
        使用 pathlib.Path 实现的文件遍历与排序，带基础性能优化。
        """
        path = Path(path)
        if not path.is_dir():
            raise NotADirectoryError(f"{path} is not a directory")
    
        def _iter(directory: Path):
            for entry in directory.iterdir():
                if entry.is_dir():
                    if include_dirs:
                        yield entry
                    if recursive:
                        yield from _iter(entry)
                else:
                    yield entry
    
        items = list(_iter(path))
    
        # 尽量减少重复 stat() 调用
        if sort_by in ("size", "mtime", "ctime"):
            # 一次性获取 stat
            stats_cache = {f: f.stat() for f in items}
        else:
            stats_cache = {}
    
        # 排序函数映射
        key_funcs = {
            "name": lambda f: f.name.lower(),
            "size": lambda f: stats_cache[f].st_size,
            "mtime": lambda f: stats_cache[f].st_mtime,
            "ctime": lambda f: stats_cache[f].st_ctime,
            "suffix": lambda f: f.suffix.lower(),
            "custom": custom_key,
        }
    
        if sort_by not in key_funcs or (sort_by == "custom" and not custom_key):
            raise ValueError(f"Invalid sort_by: {sort_by}")
    
        key_func = key_funcs[sort_by]
        return sorted(items, key=key_func, reverse=reverse)


* * *

### ✅ 性能优化点说明

| 优化点 | 说明 |
| --- | --- |
| `Path.stat()` 缓存 | 只对需要的属性（size/mtime/ctime）预取一次，避免重复系统调用 |
| 避免多次递归对象创建 | `_iter` 生成器直接 yield Path 对象 |
| 使用 `.lower()` | 提高跨平台排序一致性（文件系统区分大小写不同） |
| 按需递归 | 防止不必要的目录深度扫描 |

* * *

### ✅ 示例

    files = list_files_pathlib("/data", sort_by="mtime", reverse=True)
    for f in files:
        print(f.name, f.stat().st_size)


性能上：

*   `Path.iterdir()` 在 10 万文件级别的目录下通常比 `os.scandir()` 慢 30～50%。
    
*   但对中小规模目录（几百～几千文件），差距可以忽略，而且接口更优雅。
    
* * *

🧭 二、文件信息在不同平台上的差异（非常关键）
------------------------

`Path.stat()`（或 `os.stat()`） 返回的结果在不同系统上字段一致，但**含义略有差异**：

| 属性 | 含义 | Windows | Linux / macOS |
| --- | --- | --- | --- |
| `st_size` | 文件大小（字节） | ✅ | ✅ |
| `st_mtime` | 最后修改时间 | ✅ 文件内容修改时间 | ✅ 文件内容修改时间 |
| `st_ctime` | **创建时间** | ✅ 创建时间 | ⚠️ 元数据变更时间（change time，不是创建时间） |
| `st_atime` | 最后访问时间 | ✅ | ✅ |
| `st_mode` | 文件模式（权限） | ✅ | ✅ |

👉 因此：

*   如果你想**跨平台按“文件创建时间”排序**，请注意：
    
    *   **Windows**：`st_ctime` 是创建时间 ✅
        
    *   **Linux/macOS**：`st_ctime` 是 inode 元数据更改时间 ❌
        
    *   在 Linux 上真正的创建时间通常不可直接获取（除非使用 `os.statx()`，Python 标准库不直接支持）
        

🧠 推荐策略：

*   按**修改时间**(`st_mtime`) 是最一致的方案。
    
*   只在 Windows 下使用 `st_ctime` 代表“创建时间”。
    
* * *

### ✅ 跨平台处理建议

    import platform
    
    def get_creation_time(path: Path):
        stat = path.stat()
        if platform.system() == "Windows":
            return stat.st_ctime  # Windows: creation time
        else:
            return stat.st_mtime  # Fallback to modify time on Unix


* * *

✅ 总结对比表
-------

| 特性 | `os.scandir()` | `Path.iterdir()` |
| --- | --- | --- |
| 性能 | ✅ 更快 | ⚙️ 稍慢 |
| 可读性 | 普通 | ✅ 更优雅（Path API） |
| 跨平台性 | ✅ | ✅ |
| 能否递归 | 手动写递归 | 手动写递归 |
| 支持排序 | 手动实现 | 手动实现 |
| 推荐用途 | 性能敏感场景 | 通用/优雅写法场景 |

* * *

是否希望我帮你加一个「**自动检测平台并选择最优实现**」的封装？  
也就是：在 Windows / Linux 上都用一个统一函数 `list_files_auto()`，自动决定用 `os.scandir()` 还是 `Path.iterdir()`，并保证排序行为一致。

---

## 我的提问：

我是需要创建时间的，因为修改时间无法确定我需要的文件顺序是否符合要求，但创建时间是可以确定的

---

## ChatGPT 回答：

非常好的决定 ✅  
——你选择以「文件创建时间」排序是对的，尤其在你需要**稳定反映文件生成顺序**时。  
但是这在**不同平台下确实存在坑**。下面我会：

1.  明确地告诉你各平台的创建时间字段差异；
    
2.  给出一个真正**跨平台可靠的 `get_creation_time()` 实现**；
    
3.  最后提供一个经过优化的 **高性能文件遍历排序函数（支持按创建时间排序）**。
    

* * *

🧩 一、不同平台的创建时间差异（核心点）
---------------------

| 属性 | Windows | Linux | macOS |
| --- | --- | --- | --- |
| `st_ctime` | ✅ 创建时间（Creation time） | ⚠️ inode 元数据修改时间（非创建时间） | ⚠️ 同 Linux（非创建时间） |
| `st_birthtime` | ❌ 不存在 | ❌ 不存在 | ✅ 文件创建时间（Creation time） |

> 🔸总结：
> 
> *   ✅ **Windows**：可以直接用 `st_ctime`。
>     
> *   ✅ **macOS**：使用 `st_birthtime`。
>     
> *   ⚠️ **Linux**：没有官方创建时间，只能尝试 `os.statx()`（Python 3.11+ 支持）或降级为 `mtime`。
>     

* * *

🧠 二、通用函数：`get_creation_time()`
-------------------------------

下面的函数会自动判断当前平台，选择最合适的方案：

    import os
    import platform
    from pathlib import Path
    
    def get_creation_time(path: Path) -> float:
        """
        获取文件创建时间（跨平台方案）。
        返回一个 float 时间戳。
        """
        stat = path.stat()
        system = platform.system()
    
        if system == "Windows":
            return stat.st_ctime  # 真正的创建时间
        elif hasattr(stat, "st_birthtime"):  # macOS
            return stat.st_birthtime
        else:
            # Linux 无创建时间，可尝试使用 os.statx()（Python 3.11+）
            try:
                import os
                statx = os.statx(path, os.AT_FDCWD, os.AT_STATX_BASIC_STATS)
                return statx.stx_btime.tv_sec + statx.stx_btime.tv_nsec / 1e9
            except Exception:
                # 回退到修改时间
                return stat.st_mtime


> 💡 这段代码在：
> 
> *   **Windows** 上返回创建时间；
>     
> *   **macOS** 上返回 `st_birthtime`；
>     
> *   **Linux** 上尝试用 `statx`（如不可用则回退 `mtime`）。
>     

* * *

⚙️ 三、整合成高性能排序函数（带创建时间支持）
------------------------

我们把它整合进 `os.scandir()` 版本中，获得更高性能：

    import os
    from pathlib import Path
    from typing import Callable, List, Union
    
    def list_files(
        path: Union[str, Path],
        sort_by: str = "name",
        reverse: bool = False,
        recursive: bool = False,
        custom_key: Callable[[os.DirEntry], any] = None,
        include_dirs: bool = False,
    ) -> List[Path]:
        """
        高性能文件遍历与排序，支持跨平台创建时间。
        """
        path = Path(path)
        if not path.is_dir():
            raise NotADirectoryError(f"{path} is not a directory")
    
        def _scan(directory: Path):
            with os.scandir(directory) as it:
                for entry in it:
                    if entry.is_dir(follow_symlinks=False):
                        if include_dirs:
                            yield entry
                        if recursive:
                            yield from _scan(Path(entry.path))
                    else:
                        yield entry
    
        entries = list(_scan(path))
    
        # 跨平台创建时间函数
        def get_creation_time_entry(entry: os.DirEntry):
            p = Path(entry.path)
            return get_creation_time(p)
    
        # 排序 key
        key_funcs = {
            "name": lambda e: e.name.lower(),
            "size": lambda e: e.stat().st_size,
            "mtime": lambda e: e.stat().st_mtime,
            "ctime": get_creation_time_entry,
            "suffix": lambda e: Path(e.name).suffix.lower(),
            "custom": custom_key,
        }
    
        if sort_by not in key_funcs or (sort_by == "custom" and not custom_key):
            raise ValueError(f"Invalid sort_by: {sort_by}")
    
        key_func = key_funcs[sort_by]
        return [Path(e.path) for e in sorted(entries, key=key_func, reverse=reverse)]


* * *

✅ 四、使用示例
--------

### 按创建时间排序

    files = list_files("/data", sort_by="ctime")
    for f in files:
        print(f.name, get_creation_time(f))


### 按创建时间倒序（最新的在前）

    files = list_files("/data", sort_by="ctime", reverse=True)


### 按创建时间递归遍历所有文件

    files = list_files("/data", sort_by="ctime", recursive=True)


* * *

🧪 五、验证方式
---------

在三大系统中测试以下代码，可以确认创建时间是否正确：

    from datetime import datetime
    from pathlib import Path
    
    p = Path("/path/to/file.txt")
    print("创建时间:", datetime.fromtimestamp(get_creation_time(p)))
    print("修改时间:", datetime.fromtimestamp(p.stat().st_mtime))
    print("ctime 原始值:", p.stat().st_ctime)


* * *

🧩 六、性能总结
---------

| 排序依据 | 性能 | 跨平台可靠性 | 备注 |
| --- | --- | --- | --- |
| `mtime` | ✅ 快 | ✅ 一致 | 常见方案 |
| `ctime`（Windows/macOS） | ✅ 快 | ✅ 准确 | 推荐方案 |
| `ctime`（Linux） | ⚠️ 不可靠 | ❌ | 用 `statx` 可改进 |
| `get_creation_time()` | ⚙️ 稍慢 | ✅ 最通用 | 跨平台正确 |

* * *

是否希望我帮你在这个基础上再封装一个版本：

*   自动缓存每个文件的 stat 信息（避免多次访问）
    
*   并支持「优先使用创建时间，否则回退修改时间」的稳定排序？  
    这样在任何系统上都能稳定按文件生成顺序遍历。

---

## 我的提问：

希望，再加上可以以多个排序的方案，比如\[create\_time, filesize\]时就会先按create\_time排序，再按filesize排序。还有一个要求是需要适配逆序，可以仿照Django在前面加-号的方式

---

## ChatGPT 回答：

非常棒 ✅，你的需求非常专业，也非常有工程性。我们要实现的就是一个：

> ✅ 高性能 + 多键排序 + Django 风格排序字段（支持 `-字段名` 表示逆序）  
> ✅ 跨平台正确获取创建时间  
> ✅ 自动缓存 stat 信息，减少系统调用

* * *

🧩 最终方案：`list_files_advanced()`
-------------------------------

完整代码如下（性能优先 + 高可读性 + 全平台兼容）：

    import os
    import platform
    from pathlib import Path
    from typing import Callable, List, Union


​    
    # ------------------------------
    # ✅ 跨平台创建时间函数
    # ------------------------------
    def get_creation_time(path: Path) -> float:
        """
        获取文件创建时间（跨平台兼容方案）。
        - Windows: 使用 st_ctime（创建时间）
        - macOS: 使用 st_birthtime
        - Linux: 尝试 statx，否则回退 mtime
        """
        stat = path.stat()
        system = platform.system()
    
        if system == "Windows":
            return stat.st_ctime
        elif hasattr(stat, "st_birthtime"):  # macOS
            return stat.st_birthtime
        else:
            # Linux: 尝试使用 statx（Python 3.11+）
            try:
                statx = os.statx(path, os.AT_FDCWD, os.AT_STATX_BASIC_STATS)
                btime = statx.stx_btime
                return btime.tv_sec + btime.tv_nsec / 1e9
            except Exception:
                return stat.st_mtime


​    
    # ------------------------------
    # ✅ 主函数：高性能多条件排序
    # ------------------------------
    def list_files_advanced(
        path: Union[str, Path],
        order_by: List[str] = None,
        recursive: bool = False,
        include_dirs: bool = False,
        custom_keys: dict[str, Callable[[os.DirEntry], any]] = None,
    ) -> List[Path]:
        """
        高性能文件遍历 + 多字段排序（支持 -前缀逆序）
        
        参数：
            path: 根目录
            order_by: 排序字段列表，例如：
                ["create_time", "-size", "name"]
            recursive: 是否递归遍历子目录
            include_dirs: 是否包含目录
            custom_keys: 可注入自定义排序字段函数，如 {"custom": lambda e: ...}
    
        支持字段：
            name, size, mtime, create_time, suffix
    
        返回：
            List[Path]
        """
        path = Path(path)
        if not path.is_dir():
            raise NotADirectoryError(f"{path} is not a directory")
    
        # 高性能扫描
        def _scan(directory: Path):
            with os.scandir(directory) as it:
                for entry in it:
                    if entry.is_dir(follow_symlinks=False):
                        if include_dirs:
                            yield entry
                        if recursive:
                            yield from _scan(Path(entry.path))
                    else:
                        yield entry
    
        entries = list(_scan(path))
        if not entries:
            return []
    
        # 一次性缓存 stat 信息，减少系统调用
        stats_cache = {}
        for e in entries:
            try:
                stats_cache[e.path] = e.stat()
            except FileNotFoundError:
                # 文件可能被删除
                continue
    
        # 字段对应函数映射
        base_keys: dict[str, Callable[[os.DirEntry], any]] = {
            "name": lambda e: e.name.lower(),
            "size": lambda e: stats_cache[e.path].st_size,
            "mtime": lambda e: stats_cache[e.path].st_mtime,
            "create_time": lambda e: get_creation_time(Path(e.path)),
            "suffix": lambda e: Path(e.name).suffix.lower(),
        }
    
        # 合并用户自定义排序键
        if custom_keys:
            base_keys.update(custom_keys)
    
        if not order_by:
            order_by = ["name"]
    
        # 多字段排序（后字段优先）
        # Python 的 sort 是稳定排序，所以需要逆序地应用排序字段
        for field in reversed(order_by):
            reverse = field.startswith("-")
            key_name = field.lstrip("-")
    
            if key_name not in base_keys:
                raise ValueError(f"Unsupported sort field: {key_name}")
    
            entries.sort(key=base_keys[key_name], reverse=reverse)
    
        return [Path(e.path) for e in entries]


* * *

✅ 使用示例
------

### 1️⃣ 按创建时间升序

    files = list_files_advanced("/data", order_by=["create_time"])


### 2️⃣ 按创建时间倒序（最新文件优先）

    files = list_files_advanced("/data", order_by=["-create_time"])


### 3️⃣ 先按创建时间，再按文件大小

    files = list_files_advanced("/data", order_by=["create_time", "size"])


### 4️⃣ 混合正逆序排序（创建时间倒序 + 大小升序）

    files = list_files_advanced("/data", order_by=["-create_time", "size"])


### 5️⃣ 添加自定义排序字段（例如按文件名中数字）

    import re
    def numeric_key(e):
        m = re.search(r'\d+', e.name)
        return int(m.group()) if m else 0
    
    files = list_files_advanced(
        "/data",
        order_by=["-create_time", "custom"],
        custom_keys={"custom": numeric_key}
    )


* * *

⚙️ 性能优化点回顾
----------

| 优化项 | 说明 |
| --- | --- |
| ✅ 使用 `os.scandir()` | 获取 `DirEntry`，`stat()` 调用延迟执行 |
| ✅ 缓存所有 `stat()` | 避免重复调用系统函数 |
| ✅ 稳定多键排序 | 使用稳定排序算法（Python 内置 Timsort） |
| ✅ 平台适配 | Windows / macOS / Linux 全兼容创建时间 |
| ✅ 支持自定义排序 | 灵活扩展 |

* * *

🧪 验证输出
-------

    from datetime import datetime
    
    for f in files[:10]:
        ctime = datetime.fromtimestamp(get_creation_time(f))
        print(f"{ctime} | {f.stat().st_size:>8} | {f.name}")


输出类似：

    2025-11-11 10:32:00 |     1024 | report1.txt
    2025-11-11 10:33:05 |     2048 | report2.txt


* * *

✅ 可选增强
------

我可以帮你进一步扩展：

*   支持分页（`limit`, `offset`）；
    
*   支持“仅返回部分字段”（例如：名称 + 创建时间 + 大小）；
    
*   支持异步扫描（用线程池处理 stat 提升大目录性能）。
    
* * *

是否希望我帮你加上分页与字段选择功能（类似数据库 ORM 的 `limit`、`offset`、`only` 功能）？  
👉 这样你可以在前端文件管理或 API 查询中更高效地使用。

---

