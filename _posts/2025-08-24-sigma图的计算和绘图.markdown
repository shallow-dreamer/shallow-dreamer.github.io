---
layout:     post
title:      "sigma图的计算和绘图"
subtitle:   ""
date:       2025-08-24
author:     " Shallow Dreamer"
header-img: "img/post-bg-js-version.jpg"
tags:
    - python
---

下面给出完整方案，包括 **sigma 计算方法** 和 **前端 echarts 绘图示例**。

------

## 1. Sigma 计算方法

假设：

- `y_true`：真实值数组（numpy array 或 list）
- `y_pred`：预测值数组（对应 loss 最小的那一轮预测结果）

### Python 实现

```python
import numpy as np

def calculate_sigma(y_true, y_pred):
    """
    计算每个样本的残差标准差 (sigma)
    """
    y_true = np.array(y_true)
    y_pred = np.array(y_pred)

    # 残差
    residuals = y_true - y_pred

    # 残差的标准差 (总体标准差)
    sigma = np.std(residuals)

    return sigma, residuals.tolist()

# 示例
y_true = [3.0, 5.0, 7.5, 10.0]
y_pred = [2.8, 5.2, 7.0, 9.8]

sigma, residuals = calculate_sigma(y_true, y_pred)
print("sigma:", sigma)
print("residuals:", residuals)  # 每个点的残差可用于绘制散点图
```

返回值：

- `sigma`：整体的标准差，可绘制水平参考线
- `residuals`：每个样本的残差，可作为图表的 y 轴数据

------

## 2. 前端 ECharts 绘图示例

以下是一个 **残差与样本索引的散点图**，并添加 ±sigma 的参考线。

```html
<div id="sigmaChart" style="width: 800px; height: 400px;"></div>

<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
<script>
    // 假设后端返回以下数据
    const residuals = [0.2, -0.2, 0.5, -0.2]; // 每个点的残差
    const sigma = 0.3; // 标准差

    // x 轴为样本索引
    const xData = residuals.map((_, index) => index + 1);

    const chartDom = document.getElementById('sigmaChart');
    const myChart = echarts.init(chartDom);

    const option = {
        title: { text: '训练过程 Sigma 残差图' },
        tooltip: { trigger: 'axis' },
        xAxis: {
            type: 'category',
            data: xData,
            name: '样本索引'
        },
        yAxis: {
            type: 'value',
            name: '残差'
        },
        series: [
            {
                name: '残差',
                type: 'scatter',
                data: residuals,
                symbolSize: 8,
                itemStyle: {
                    color: '#5470C6'
                }
            },
            // 正 sigma 参考线
            {
                name: '+sigma',
                type: 'line',
                data: Array(xData.length).fill(sigma),
                lineStyle: { type: 'dashed', color: '#91cc75' },
                symbol: 'none'
            },
            // 负 sigma 参考线
            {
                name: '-sigma',
                type: 'line',
                data: Array(xData.length).fill(-sigma),
                lineStyle: { type: 'dashed', color: '#ee6666' },
                symbol: 'none'
            }
        ]
    };

    myChart.setOption(option);
</script>
```

------

## 3. 可扩展点

- 若需要绘制 **训练过程中每一轮的 sigma 曲线**，可以把每轮计算出的 `sigma` 存储为数组，在 echarts 中绘制折线图。
- 若需要区分训练集和验证集，可分别绘制两组残差。

------

下面详细说明如何计算需要的数据、定义数据格式及其含义，并提供大数据量时的优化方案。

------

## 1. 需要计算的数据

### 基本概念

- **真实值 (y_true)**：模型在测试集/验证集上的真实标签。
- **预测值 (y_pred)**：对应某一轮次（通常是 loss 最小轮次）的预测结果。
- **残差 (residual)**：残差 = `y_true - y_pred`，表示每个点的预测误差。
- **σ (sigma)**：残差的标准差，衡量整体预测的离散程度。

### 数据计算步骤

1. **计算每个样本的残差**：

   ```python
   residuals = y_true - y_pred
   ```

2. **计算整体 sigma**：

   ```python
   sigma = np.std(residuals)
   ```

3. **可选：分段统计**

   - 若样本量很大，可以按区间计算残差的均值和标准差（见大数据量处理部分）。

------

## 2. 数据格式设计

### 单轮残差图（Scatter + 参考线）

适用于显示 **loss 最小轮次** 的残差分布。

```json
{
  "xData": [1, 2, 3, 4, 5],
  "residuals": [0.2, -0.1, 0.5, -0.3, 0.1],
  "sigma": 0.25
}
```

- `xData`：样本索引或时间戳
- `residuals`：对应的残差值
- `sigma`：整体标准差（可绘制参考线）

------

### 多轮 sigma 曲线（Loss + Sigma 监控）

如果要展示每一轮次的 sigma（例如判断收敛情况），格式可为：

```json
{
  "epochs": [1, 2, 3, 4, 5],
  "sigmaList": [0.8, 0.6, 0.4, 0.35, 0.3],
  "lossList": [1.2, 0.9, 0.5, 0.4, 0.3]
}
```

- `epochs`：训练轮次
- `sigmaList`：每轮残差标准差
- `lossList`：每轮损失值（用于双轴图或参考最优点）

------

## 3. 数据量大的处理方案

当样本量很大（> 5万点）时，前端直接绘制所有点会卡顿，需要数据降采样或聚合。

### 3.1 后端降采样

仅取等间隔的一部分点：

```python
def downsample(residuals, step=10):
    return residuals[::step]
```

### 3.2 区间统计（推荐）

将数据按区间聚合，展示统计特征而非每个点：

```python
import numpy as np

def aggregate_residuals(residuals, bin_size=100):
    n_bins = len(residuals) // bin_size
    agg_data = []
    for i in range(n_bins):
        segment = residuals[i*bin_size:(i+1)*bin_size]
        agg_data.append({
            "mean": float(np.mean(segment)),
            "std": float(np.std(segment)),
            "start": i*bin_size,
            "end": (i+1)*bin_size
        })
    return agg_data
```

前端绘制区间均值曲线 + 上下标准差带，更直观且性能好。

------

## 4. 推荐工作流

1. **训练过程中**：
   - 每轮保存 `y_pred` 和 `loss`。
   - 计算并记录 `sigma`。
2. **训练结束后**：
   - 找出 loss 最小轮次。
   - 获取该轮次的 `residuals` 和 `sigma`。
3. **前端展示**：
   - 小数据：散点图 + sigma 参考线。
   - 大数据：区间统计图或降采样曲线。

------

以下是完整方案，包括 **Python 数据计算脚本** 和 **ECharts 可视化（支持大数据量）**。

------

## 1. Python 数据计算脚本

该脚本完成以下功能：

1. 在每个训练轮次计算 `sigma` 并记录。
2. 找出 **loss 最小轮次**。
3. 计算该轮次的残差数据并进行降采样/聚合处理。

```python
import numpy as np

def calculate_sigma(y_true, y_pred):
    """
    计算残差及其标准差
    """
    residuals = np.array(y_true) - np.array(y_pred)
    sigma = float(np.std(residuals))
    return sigma, residuals.tolist()

def find_best_epoch(loss_list):
    """
    找出loss最小的轮次索引
    """
    return int(np.argmin(loss_list))

def aggregate_residuals(residuals, bin_size=100):
    """
    将残差数据按区间聚合，减少前端绘图数据量
    """
    agg_data = []
    n_bins = len(residuals) // bin_size
    for i in range(n_bins):
        segment = residuals[i*bin_size:(i+1)*bin_size]
        agg_data.append({
            "mean": float(np.mean(segment)),
            "std": float(np.std(segment)),
            "start": i*bin_size,
            "end": (i+1)*bin_size
        })
    return agg_data

# ======= 模拟训练过程 =======

epochs = 50
samples = 5000

# 模拟真实值
y_true = np.linspace(0, 10, samples)

# 模拟每轮预测与loss
y_preds = [y_true + np.random.normal(0, 1/(ep+1), samples) for ep in range(epochs)]
loss_list = [np.mean((y_true - y_pred)**2) for y_pred in y_preds]

# 每轮sigma记录
sigma_list = []
for y_pred in y_preds:
    sigma, _ = calculate_sigma(y_true, y_pred)
    sigma_list.append(sigma)

# 找出loss最小轮次
best_epoch = find_best_epoch(loss_list)
best_y_pred = y_preds[best_epoch]

# 获取残差数据
_, residuals = calculate_sigma(y_true, best_y_pred)

# 降采样 / 聚合
agg_residuals = aggregate_residuals(residuals, bin_size=100)

# 返回给前端的数据
result = {
    "epochs": list(range(1, epochs+1)),
    "lossList": loss_list,
    "sigmaList": sigma_list,
    "bestEpochResiduals": residuals,
    "sigma": sigma_list[best_epoch],
    "aggregatedResiduals": agg_residuals
}

print(result.keys())  # ['epochs', 'lossList', 'sigmaList', 'bestEpochResiduals', 'sigma', 'aggregatedResiduals']
```

### 返回数据说明

- `epochs`：训练轮次数组。
- `lossList`：每轮次损失值。
- `sigmaList`：每轮次的 sigma。
- `bestEpochResiduals`：最佳轮次（loss 最小）对应的所有残差（原始数据）。
- `sigma`：最佳轮次的整体标准差。
- `aggregatedResiduals`：聚合后的残差数据，用于大数据量可视化。

------

## 2. 前端 ECharts 可视化

### 2.1 多轮次 sigma & loss 曲线

展示训练收敛情况。

```html
<div id="sigmaLossChart" style="width: 800px; height: 400px;"></div>
<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
<script>
const epochs = [1,2,3,4,5]; // Python返回
const sigmaList = [0.8,0.6,0.4,0.35,0.3];
const lossList = [1.2,0.9,0.5,0.4,0.3];

const chartDom = document.getElementById('sigmaLossChart');
const myChart = echarts.init(chartDom);
const option = {
    title: { text: 'Sigma & Loss 曲线' },
    tooltip: { trigger: 'axis' },
    legend: { data: ['Sigma', 'Loss'] },
    xAxis: { type: 'category', data: epochs, name: 'Epoch' },
    yAxis: [
        { type: 'value', name: 'Sigma' },
        { type: 'value', name: 'Loss' }
    ],
    series: [
        {
            name: 'Sigma',
            type: 'line',
            yAxisIndex: 0,
            data: sigmaList
        },
        {
            name: 'Loss',
            type: 'line',
            yAxisIndex: 1,
            data: lossList
        }
    ]
};
myChart.setOption(option);
</script>
```

------

### 2.2 残差图（大数据量可选聚合）

#### 原始散点图（小数据集）

```html
<div id="residualChart" style="width: 800px; height: 400px;"></div>
<script>
const residuals = [0.2, -0.1, 0.5, -0.3]; // Python返回
const sigma = 0.25;

const xData = residuals.map((_, i) => i+1);
const myChart2 = echarts.init(document.getElementById('residualChart'));
const option2 = {
    title: { text: '残差散点图' },
    xAxis: { type: 'category', data: xData, name: '样本索引' },
    yAxis: { type: 'value', name: '残差' },
    series: [
        { type: 'scatter', data: residuals },
        { type: 'line', data: Array(xData.length).fill(sigma), lineStyle:{type:'dashed'}, symbol:'none' },
        { type: 'line', data: Array(xData.length).fill(-sigma), lineStyle:{type:'dashed'}, symbol:'none' }
    ]
};
myChart2.setOption(option2);
</script>
```

#### 聚合后带标准差带状图（大数据集）

```html
<div id="aggResidualChart" style="width: 800px; height: 400px;"></div>
<script>
const aggregatedResiduals = [
    {start:0,end:100,mean:0.1,std:0.3},
    {start:100,end:200,mean:0.05,std:0.25}
]; // Python返回

const xData3 = aggregatedResiduals.map((d,i) => i);
const meanData = aggregatedResiduals.map(d => d.mean);
const upperBound = aggregatedResiduals.map(d => d.mean + d.std);
const lowerBound = aggregatedResiduals.map(d => d.mean - d.std);

const myChart3 = echarts.init(document.getElementById('aggResidualChart'));
const option3 = {
    title: { text: '聚合残差带状图' },
    xAxis: { type: 'category', data: xData3 },
    yAxis: { type: 'value' },
    series: [
        {
            type: 'line',
            data: meanData,
            name: '平均残差'
        },
        {
            type: 'line',
            data: upperBound,
            lineStyle: { opacity: 0 },
            stack: 'conf',
            symbol: 'none'
        },
        {
            type: 'line',
            data: lowerBound,
            lineStyle: { opacity: 0 },
            areaStyle: { color: 'rgba(91,155,213,0.3)' },
            stack: 'conf',
            symbol: 'none'
        }
    ]
};
myChart3.setOption(option3);
</script>
```

------

以下是完整方案，支持 **绝对残差** 与 **百分比残差** 两种计算方式，并在前端可切换显示模式。

------

## 1. Python 计算脚本

```python
import numpy as np

def calculate_residuals(y_true, y_pred, use_percentage=False):
    """
    计算残差及其标准差
    :param y_true: 真实值数组
    :param y_pred: 预测值数组
    :param use_percentage: 是否使用百分比残差
    :return: sigma, residuals (list)
    """
    y_true = np.array(y_true)
    y_pred = np.array(y_pred)

    # 避免除零
    safe_y_true = np.where(y_true == 0, 1e-8, y_true)

    if use_percentage:
        residuals = ((y_true - y_pred) / safe_y_true) * 100
    else:
        residuals = y_true - y_pred

    sigma = float(np.std(residuals))
    return sigma, residuals.tolist()


def aggregate_residuals(residuals, bin_size=100):
    """
    聚合残差数据以减少前端绘图量
    """
    agg_data = []
    n_bins = len(residuals) // bin_size
    for i in range(n_bins):
        segment = residuals[i*bin_size:(i+1)*bin_size]
        agg_data.append({
            "mean": float(np.mean(segment)),
            "std": float(np.std(segment)),
            "start": i*bin_size,
            "end": (i+1)*bin_size
        })
    return agg_data


# ===== 模拟数据 =====
samples = 5000
y_true = np.linspace(1, 100, samples)  # 避免为零
y_pred = y_true + np.random.normal(0, 5, samples)

# 计算绝对残差
sigma_abs, residuals_abs = calculate_residuals(y_true, y_pred, use_percentage=False)
agg_abs = aggregate_residuals(residuals_abs)

# 计算百分比残差
sigma_pct, residuals_pct = calculate_residuals(y_true, y_pred, use_percentage=True)
agg_pct = aggregate_residuals(residuals_pct)

# 输出给前端
result = {
    "absolute": {
        "sigma": sigma_abs,
        "residuals": residuals_abs,
        "aggregatedResiduals": agg_abs
    },
    "percentage": {
        "sigma": sigma_pct,
        "residuals": residuals_pct,
        "aggregatedResiduals": agg_pct
    }
}

print(result.keys())  # dict_keys(['absolute', 'percentage'])
```

------

## 2. 前端 ECharts 切换显示模式

### HTML & JS

```html
<div>
    <button onclick="switchMode('absolute')">绝对值残差</button>
    <button onclick="switchMode('percentage')">百分比残差</button>
</div>
<div id="residualChart" style="width: 800px; height: 400px;"></div>

<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
<script>
const chartDom = document.getElementById('residualChart');
const myChart = echarts.init(chartDom);

// 模拟后端返回数据
const chartData = {
    absolute: {
        residuals: [0.5, -0.2, 1.2, -0.8],
        sigma: 0.7
    },
    percentage: {
        residuals: [1.5, -0.4, 2.1, -1.6],
        sigma: 1.3
    }
};

function renderChart(mode) {
    const residuals = chartData[mode].residuals;
    const sigma = chartData[mode].sigma;
    const xData = residuals.map((_, i) => i + 1);

    const yAxisName = mode === 'absolute' ? '残差' : '残差 (%)';

    const option = {
        title: { text: mode === 'absolute' ? '绝对值残差图' : '百分比残差图' },
        xAxis: { type: 'category', data: xData },
        yAxis: { type: 'value', name: yAxisName },
        series: [
            { type: 'scatter', data: residuals },
            { type: 'line', data: Array(xData.length).fill(sigma), lineStyle:{type:'dashed'}, symbol:'none' },
            { type: 'line', data: Array(xData.length).fill(-sigma), lineStyle:{type:'dashed'}, symbol:'none' }
        ]
    };
    myChart.setOption(option);
}

function switchMode(mode) {
    renderChart(mode);
}

// 默认显示绝对值残差
renderChart('absolute');
</script>
```

------

## 3. 方案说明

- **后端**：一次性计算并返回 `absolute` 和 `percentage` 两种模式的数据。
- **前端**：提供按钮切换，避免重复请求。
- **聚合数据**：可扩展为带均值+标准差带状图（大数据量优化）。

------

明白了，你指的是 **±1σ、±2σ、±3σ 区间** 的统计控制图（类似质量管理中的控制图）。

------

## 1. Sigma 区间计算

残差区间计算公式：

Upperk=k×σ,Lowerk=−k×σ(k=1,2,3)\text{Upper}_k = k \times \sigma,\quad \text{Lower}_k = -k \times \sigma \quad (k = 1,2,3)

Python 示例：

```python
import numpy as np

def calculate_sigma_bands(y_true, y_pred, use_percentage=False):
    y_true = np.array(y_true)
    y_pred = np.array(y_pred)
    safe_y_true = np.where(y_true == 0, 1e-8, y_true)

    residuals = ((y_true - y_pred) / safe_y_true) * 100 if use_percentage else (y_true - y_pred)
    sigma = np.std(residuals)

    # 计算1σ、2σ、3σ上下限
    bands = {
        "1sigma": {"upper": sigma, "lower": -sigma},
        "2sigma": {"upper": 2*sigma, "lower": -2*sigma},
        "3sigma": {"upper": 3*sigma, "lower": -3*sigma},
    }
    return residuals.tolist(), sigma, bands
```

------

## 2. ECharts 3σ 图示例

### 可运行 HTML

保存为 `sigma_chart.html` 并在浏览器打开：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>3σ 控制图</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
</head>
<body>
    <div id="sigmaChart" style="width: 900px; height: 400px;"></div>

    <script>
    const residuals = [0.5, -0.2, 1.2, -0.8, 0.4, -0.1, 0.7];  // 残差
    const sigma = 0.7;  // 标准差

    const xData = residuals.map((_, i) => i + 1);

    const option = {
        title: { text: '3σ 控制图' },
        tooltip: { trigger: 'axis' },
        xAxis: { type: 'category', data: xData, name: '样本索引' },
        yAxis: { type: 'value', name: '残差' },
        series: [
            { type: 'scatter', data: residuals, name: '残差', symbolSize: 6 },

            // 1σ 线
            { type: 'line', data: Array(xData.length).fill(sigma), lineStyle:{color:'#91cc75',type:'dashed'}, symbol:'none', name:'+1σ' },
            { type: 'line', data: Array(xData.length).fill(-sigma), lineStyle:{color:'#91cc75',type:'dashed'}, symbol:'none', name:'-1σ' },

            // 2σ 线
            { type: 'line', data: Array(xData.length).fill(2*sigma), lineStyle:{color:'#fac858',type:'dashed'}, symbol:'none', name:'+2σ' },
            { type: 'line', data: Array(xData.length).fill(-2*sigma), lineStyle:{color:'#fac858',type:'dashed'}, symbol:'none', name:'-2σ' },

            // 3σ 线
            { type: 'line', data: Array(xData.length).fill(3*sigma), lineStyle:{color:'#ee6666',type:'dashed'}, symbol:'none', name:'+3σ' },
            { type: 'line', data: Array(xData.length).fill(-3*sigma), lineStyle:{color:'#ee6666',type:'dashed'}, symbol:'none', name:'-3σ' },
        ]
    };

    const myChart = echarts.init(document.getElementById('sigmaChart'));
    myChart.setOption(option);
    </script>
</body>
</html>
```

------

## 3. 特点

- 显示 ±1σ、±2σ、±3σ 的虚线参考线。
- 残差点若超出 ±3σ，表示异常点。

------

