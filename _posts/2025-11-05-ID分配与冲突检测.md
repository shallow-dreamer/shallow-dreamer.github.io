---
layout:     post
title:      "IDåˆ†é…ä¸å†²çªæ£€æµ‹"
subtitle:   ""
date:       2025-11-02
author:     " Shallow Dreamer"
header-img: "img/post-bg-js-version.jpg"
tags:
    - js


---

## æˆ‘çš„æé—®ï¼š

æˆ‘ç°åœ¨æœ‰ä¸€ä¸ªå‰ç«¯ç±»ä¼¼æ•°æ®æ± çš„é—®é¢˜ï¼šèŠ‚ç‚¹1çš„idå¿…é¡»åœ¨10000-19999ä¸­å¹¶ä¸”å¤šä¸ªèŠ‚ç‚¹1åœ¨åŒä¸€æ•°æ®é‡Œçš„idä¸èƒ½é‡å¤ï¼Œå‰©ä¸‹è¿˜æœ‰èŠ‚ç‚¹2ç­‰éƒ½ä¸€æ ·ï¼Œåªæ˜¯èŒƒå›´ä¸ä¸€æ ·ï¼Œè§„åˆ™ï¼šèŠ‚ç‚¹çš„idä¸èƒ½é‡å¤ï¼Œå¿…é¡»åœ¨èŒƒå›´å†…ï¼Œå·²æœ‰çš„èŠ‚ç‚¹idä¸èƒ½å˜åŒ–ï¼Œåœ¨å¤§é‡æ•°æ®çš„æƒ…å†µä¸‹ä¹Ÿéœ€è¦ä¿è¯ç¬¦åˆè§„åˆ™ã€‚ç°åœ¨å…ˆä»å°èŒƒå›´å¼€å§‹è¿›è¡Œå¤„ç†éªŒè¯

---

## ChatGPT å›ç­”ï¼š

éå¸¸å¥½ ğŸ‘ï¼Œä½ è¿™ä¸ªé—®é¢˜å…¶å®æ˜¯ä¸€ä¸ª **å—é™ ID åˆ†é…ä¸å†²çªæ£€æµ‹é—®é¢˜**ï¼Œå¸¦æœ‰ **å¤šåŒºé—´ã€ä¸å¯å˜å·²æœ‰å€¼ã€å”¯ä¸€æ€§çº¦æŸ** çš„ç‰¹ç‚¹ã€‚æˆ‘ä»¬å¯ä»¥å…ˆä»å°èŒƒå›´æ¨¡æ‹Ÿå®ç°ä¸€å¥—å®‰å…¨è§„åˆ™ï¼Œç¡®ä¿ä»¥åå¯ä»¥æ‰©å±•åˆ°å¤§è§„æ¨¡åœºæ™¯ã€‚

* * *

ğŸ§© é—®é¢˜é‡è¿°
-------

ä½ æœ‰å¤šä¸ªâ€œèŠ‚ç‚¹ç±»å‹â€ï¼Œä¾‹å¦‚ï¼š

| èŠ‚ç‚¹ç±»å‹ | ID èŒƒå›´ | å¤‡æ³¨ |
| --- | --- | --- |
| èŠ‚ç‚¹1 | 10000â€“19999 | ID ä¸èƒ½é‡å¤ |
| èŠ‚ç‚¹2 | 20000â€“29999 | ID ä¸èƒ½é‡å¤ |
| èŠ‚ç‚¹3 | 30000â€“39999 | ID ä¸èƒ½é‡å¤ |

è¦æ±‚ï¼š

1.  æ¯ä¸ªèŠ‚ç‚¹ç±»å‹å†…çš„ ID ä¸èƒ½é‡å¤ï¼›
    
2.  ä¸åŒç±»å‹ä¹‹é—´çš„ ID **ä¹Ÿä¸èƒ½å†²çª**ï¼›
    
3.  å·²æœ‰çš„ ID ä¸èƒ½å˜åŒ–ï¼›
    
4.  æ’å…¥æ–°èŠ‚ç‚¹æ—¶è‡ªåŠ¨åˆ†é…ä¸€ä¸ªåˆæ³•ä¸”å”¯ä¸€çš„ IDï¼›
    
5.  èƒ½åœ¨å¤§é‡æ•°æ®ä¸­å¿«é€Ÿæ£€æŸ¥å¹¶ä¿æŒæ­£ç¡®æ€§ã€‚
    

* * *

ğŸ§  æ€è·¯è®¾è®¡ï¼ˆå°èŒƒå›´éªŒè¯ç‰ˆï¼‰
---------------

æˆ‘ä»¬å…ˆå®ç°ä¸€ä¸ªåŸºç¡€çš„ ID ç®¡ç†å™¨ï¼Œç”¨ Python ä¸¾ä¾‹ï¼ˆå‰ç«¯å¯ä»¥ later æ”¹ä¸º JS å®ç°ç›¸åŒé€»è¾‘ï¼‰ï¼š

    class IDManager:
        def __init__(self):
            self.rules = {
                "node1": (10000, 19999),
                "node2": (20000, 29999),
                "node3": (30000, 39999),
            }
            self.used_ids = set()
            self.assigned = {key: {} for key in self.rules}
    
        def add_existing(self, node_type, node_id):
            """æ³¨å†Œå·²æœ‰èŠ‚ç‚¹"""
            if not self._check_in_range(node_type, node_id):
                raise ValueError(f"{node_type} çš„ ID {node_id} ä¸åœ¨åˆæ³•èŒƒå›´ {self.rules[node_type]}")
            if node_id in self.used_ids:
                raise ValueError(f"ID {node_id} å·²è¢«å ç”¨")
            self.used_ids.add(node_id)
            self.assigned[node_type][node_id] = True
    
        def allocate_new(self, node_type):
            """åˆ†é…æ–°çš„å”¯ä¸€ ID"""
            start, end = self.rules[node_type]
            for new_id in range(start, end + 1):
                if new_id not in self.used_ids:
                    self.used_ids.add(new_id)
                    self.assigned[node_type][new_id] = True
                    return new_id
            raise RuntimeError(f"{node_type} çš„ ID èŒƒå›´å·²æ»¡")
    
        def _check_in_range(self, node_type, node_id):
            start, end = self.rules[node_type]
            return start <= node_id <= end
    
        def summary(self):
            """æŸ¥çœ‹å½“å‰çŠ¶æ€"""
            return {
                node_type: list(ids.keys()) for node_type, ids in self.assigned.items()
            }


* * *

### âœ… ä½¿ç”¨ç¤ºä¾‹ï¼ˆå°èŒƒå›´æµ‹è¯•ï¼‰

    id_mgr = IDManager()
    
    # æ·»åŠ å·²æœ‰æ•°æ®
    id_mgr.add_existing("node1", 10001)
    id_mgr.add_existing("node2", 20005)
    
    # è‡ªåŠ¨åˆ†é…æ–°èŠ‚ç‚¹
    print("æ–°èŠ‚ç‚¹1åˆ†é…ID:", id_mgr.allocate_new("node1"))  # e.g. 10000
    print("æ–°èŠ‚ç‚¹2åˆ†é…ID:", id_mgr.allocate_new("node2"))  # e.g. 20000
    
    # å†æ¬¡æŸ¥çœ‹å½“å‰çŠ¶æ€
    print(id_mgr.summary())


è¾“å‡ºï¼š

    æ–°èŠ‚ç‚¹1åˆ†é…ID: 10000
    æ–°èŠ‚ç‚¹2åˆ†é…ID: 20000
    {
      'node1': [10001, 10000],
      'node2': [20005, 20000],
      'node3': []
    }


* * *

âš™ï¸ ç‰¹ç‚¹ä¸æ‰©å±•
--------

| åŠŸèƒ½ | å½“å‰å®ç° | å¯æ‰©å±•æ–¹å‘ |
| --- | --- | --- |
| å”¯ä¸€æ€§ | âœ… å…¨å±€ `used_ids` æ§åˆ¶ | å¯æ”¹ä¸ºæ•°æ®åº“ç´¢å¼•æˆ– Redis set |
| èŒƒå›´æ£€æµ‹ | âœ… æ¯ç±»èŒƒå›´æ£€æŸ¥ | å¯åŠ¨æ€é…ç½®æˆ–ä»é…ç½®æ–‡ä»¶åŠ è½½ |
| ä¸å˜æ€§ | âœ… å·²æ³¨å†Œä¸å†ä¿®æ”¹ | å¯åœ¨æ¥å£å±‚åŠ ä¿æŠ¤é€»è¾‘ |
| æ€§èƒ½ | âš ï¸ å°èŒƒå›´æµ‹è¯•OK | å¤§èŒƒå›´å¯ä½¿ç”¨ bitmap / interval tree ä¼˜åŒ–æŸ¥æ‰¾ |
| å¹¶å‘å®‰å…¨ | âŒ æš‚æœªè€ƒè™‘ | å¯ç”¨é”æˆ–æ•°æ®åº“äº‹åŠ¡ä¿è¯ |

* * *

ğŸ”„ å‰ç«¯å®ç°æ–¹å‘ï¼ˆVue/JSï¼‰
-----------------

å¦‚æœä½ æƒ³åœ¨å‰ç«¯å…ˆéªŒè¯é€»è¾‘ï¼Œå¯ä»¥ç”¨ç±»ä¼¼ç»“æ„ï¼š

    class IDManager {
      constructor() {
        this.rules = {
          node1: [10000, 19999],
          node2: [20000, 29999],
          node3: [30000, 39999],
        };
        this.usedIds = new Set();
        this.assigned = Object.fromEntries(Object.keys(this.rules).map(k => [k, new Set()]));
      }
    
      addExisting(type, id) {
        const [start, end] = this.rules[type];
        if (id < start || id > end) throw new Error(`${type} çš„ ID ${id} ä¸åˆæ³•`);
        if (this.usedIds.has(id)) throw new Error(`ID ${id} å·²è¢«ä½¿ç”¨`);
        this.usedIds.add(id);
        this.assigned[type].add(id);
      }
    
      allocateNew(type) {
        const [start, end] = this.rules[type];
        for (let id = start; id <= end; id++) {
          if (!this.usedIds.has(id)) {
            this.usedIds.add(id);
            this.assigned[type].add(id);
            return id;
          }
        }
        throw new Error(`${type} çš„ ID èŒƒå›´å·²æ»¡`);
      }
    }


* * *

æ˜¯å¦å¸Œæœ›æˆ‘å¸®ä½ æŠŠè¿™ä¸ªé€»è¾‘æ‰©å±•æˆä¸€ä¸ª **å‰ç«¯å¯äº¤äº’çš„å°é¡µé¢**ï¼ˆè¾“å…¥èŠ‚ç‚¹ç±»å‹ â†’ è‡ªåŠ¨åˆ†é…ID â†’ æ˜¾ç¤ºå·²ç”¨IDï¼‰ï¼Œæ–¹ä¾¿ä½ åœ¨ Vue3 ä¸­éªŒè¯ï¼Ÿ  
è¿™æ ·å¯ä»¥ç›´è§‚çœ‹æ•ˆæœå¹¶æµ‹è¯•å¤§è§„æ¨¡æ•°æ®å¤„ç†ã€‚

---

## æˆ‘çš„æé—®ï¼š

æš‚æ—¶ä¸éœ€è¦æ ¡éªŒï¼Œéœ€è¦ä¿è¯å”¯ä¸€ä¸”åœ¨èŒƒå›´

---

## ChatGPT å›ç­”ï¼š

æ˜ç™½ âœ…

ä½ ç°åœ¨çš„é‡ç‚¹æ˜¯ï¼š

*   **ä¸éœ€è¦åšé‡å¤æ£€æŸ¥æˆ–åˆæ³•æ€§æç¤º**ï¼ˆå³ä¸ raise errorï¼‰
    
*   ä½†ä»éœ€**ä¿è¯åˆ†é…çš„ ID å”¯ä¸€ä¸”åœ¨æŒ‡å®šèŒƒå›´å†…**ï¼ˆè‡ªåŠ¨åˆ†é…é€»è¾‘æ­£ç¡®ï¼‰ã€‚
    

é‚£æˆ‘ä»¬å¯ä»¥æç®€åŒ–é€»è¾‘ï¼Œåªå…³æ³¨â€œåˆ†é…ç­–ç•¥ + èŒƒå›´æ§åˆ¶ + å”¯ä¸€ä¿è¯â€ã€‚

* * *

âœ… ç²¾ç®€ç‰ˆå®ç°ï¼ˆPython ç¤ºä¾‹ï¼‰
------------------

    class IDManager:
        def __init__(self):
            self.rules = {
                "node1": (10000, 19999),
                "node2": (20000, 29999),
                "node3": (30000, 39999),
            }
            self.used_ids = set()
            self.assigned = {k: set() for k in self.rules}
    
        def add_existing(self, node_type, node_id):
            """ç™»è®°å·²æœ‰çš„èŠ‚ç‚¹ï¼ˆä¸åšæ ¡éªŒï¼Œä½†ä¿æŒå”¯ä¸€ï¼‰"""
            if node_id not in self.used_ids:
                self.used_ids.add(node_id)
                self.assigned[node_type].add(node_id)
    
        def allocate_new(self, node_type):
            """åˆ†é…æ–° IDï¼ˆåªä¿è¯å”¯ä¸€+èŒƒå›´ï¼‰"""
            start, end = self.rules[node_type]
            # ä»èŒƒå›´å†…ä¾æ¬¡æ‰¾æœªç”¨çš„ ID
            for new_id in range(start, end + 1):
                if new_id not in self.used_ids:
                    self.used_ids.add(new_id)
                    self.assigned[node_type].add(new_id)
                    return new_id
            # å¦‚æœæ»¡äº†å°±è¿”å› None
            return None
    
        def summary(self):
            return {
                node_type: sorted(list(ids))
                for node_type, ids in self.assigned.items()
            }


* * *

### ğŸ”¹ ç¤ºä¾‹ä½¿ç”¨

    id_mgr = IDManager()
    
    # åŠ å…¥ä¸€äº›å·²æœ‰æ•°æ®
    id_mgr.add_existing("node1", 10005)
    id_mgr.add_existing("node2", 20010)
    
    # åˆ†é…æ–°çš„ ID
    print("æ–°èŠ‚ç‚¹1:", id_mgr.allocate_new("node1"))  # 10000
    print("æ–°èŠ‚ç‚¹1:", id_mgr.allocate_new("node1"))  # 10001
    print("æ–°èŠ‚ç‚¹2:", id_mgr.allocate_new("node2"))  # 20000
    
    # æŸ¥çœ‹å½“å‰çŠ¶æ€
    print(id_mgr.summary())


è¾“å‡ºï¼š

    æ–°èŠ‚ç‚¹1: 10000
    æ–°èŠ‚ç‚¹1: 10001
    æ–°èŠ‚ç‚¹2: 20000
    {'node1': [10000, 10001, 10005], 'node2': [20000, 20010], 'node3': []}


* * *

âœ… ç‰¹ç‚¹
----

*   ä¿è¯åˆ†é…çš„ IDï¼š
    
    *   åœ¨å¯¹åº”èŠ‚ç‚¹ç±»å‹çš„èŒƒå›´å†…ï¼›
        
    *   å…¨å±€å”¯ä¸€ï¼›
        
    *   å·²æœ‰çš„ä¸ä¼šè¢«è¦†ç›–ï¼›
    
*   ä¸ä¼šæŠ¥é”™ã€ä¸åšèŒƒå›´åˆæ³•æ€§æ ¡éªŒï¼›
    
*   è¿”å› `None` è¡¨ç¤ºè¯¥ç±»å‹çš„èŒƒå›´å·²åˆ†é…å®Œã€‚
    
* * *

æ˜¯å¦å¸Œæœ›æˆ‘å¸®ä½ å†™æˆ **å‰ç«¯ï¼ˆVue/JSï¼‰ç‰ˆæœ¬**ï¼Œæ–¹ä¾¿ç›´æ¥åœ¨æ•°æ®æ± é¡µé¢ä¸­ç®¡ç†èŠ‚ç‚¹ IDï¼Ÿ  
æˆ‘å¯ä»¥æä¾›ä¸€ä¸ª `IDManager.js` æ¨¡å—ï¼Œä¸“é—¨ç”¨äºè‡ªåŠ¨åˆ†é…å’Œè¿½è¸ªã€‚

---

## æˆ‘çš„æé—®ï¼š

æˆ‘è¦çš„å°±æ˜¯å‰ç«¯çš„ç‰ˆæœ¬ï¼Œå› ä¸ºè¿™ä¸€å—åœ¨é¡µé¢ä¸­ä¼šæœ‰å¤šä¸ªï¼Œæ¯”å¦‚æˆ‘æœ‰å¤šä¸ªç”»å¸ƒï¼Œç”»å¸ƒä¸­æ˜¯èŠ‚ç‚¹ï¼Œä¸Šé¢çš„èŠ‚ç‚¹å°±æ˜¯è¦ç¬¦åˆè¿™äº›è§„åˆ™çš„

---

## ChatGPT å›ç­”ï¼š

éå¸¸æ¸…æ¥š âœ…

ä½ çš„åœºæ™¯æ˜¯è¿™æ ·çš„ï¼š

*   é¡µé¢ä¸Šå¯èƒ½åŒæ—¶å­˜åœ¨å¤šä¸ª**ç”»å¸ƒï¼ˆcanvasï¼‰**ï¼›
    
*   æ¯ä¸ªç”»å¸ƒä¸­æœ‰å¤šä¸ªèŠ‚ç‚¹ï¼ˆnode1ã€node2ã€node3...ï¼‰ï¼›
    
*   æ¯ç±»èŠ‚ç‚¹çš„ ID **å¿…é¡»åœ¨æŒ‡å®šèŒƒå›´å†…**ï¼Œå¹¶ä¸” **åœ¨æ‰€æœ‰ç”»å¸ƒå†…å…¨å±€å”¯ä¸€**ï¼›
    
*   å·²æœ‰èŠ‚ç‚¹ ID ä¸å¯å˜ï¼›
    
*   åœ¨æ–°å¢èŠ‚ç‚¹æ—¶ï¼Œåªè¦ä¿è¯ **ID å”¯ä¸€ä¸”åœ¨èŒƒå›´å†…** å³å¯ï¼Œä¸éœ€è¦å¤æ‚æ ¡éªŒæˆ–æŠ¥é”™æç¤ºã€‚
    
* * *

ğŸ’¡ å‰ç«¯é€šç”¨æ–¹æ¡ˆï¼šIDManager.js
----------------------

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå¯ç›´æ¥æ”¾åœ¨å‰ç«¯å·¥ç¨‹ï¼ˆVue3 æˆ–æ™®é€š JSï¼‰ä½¿ç”¨çš„æ¨¡å—ã€‚  
ä½ å¯ä»¥åœ¨æ¯ä¸ªç”»å¸ƒå®ä¾‹ä¸­å…±äº«åŒä¸€ä¸ª `IDManager` å®ä¾‹ï¼Œç¡®ä¿å…¨å±€å”¯ä¸€æ€§ã€‚

* * *

### ğŸ§± `IDManager.js`

    export default class IDManager {
      constructor(rules) {
        // è§„åˆ™å®šä¹‰ï¼Œä¾‹å¦‚ï¼š
        // { node1: [10000, 19999], node2: [20000, 29999] }
        this.rules = rules;
        this.usedIds = new Set();        // å…¨å±€å·²ä½¿ç”¨ID
        this.assigned = {};              // å„ç±»å‹èŠ‚ç‚¹çš„å·²åˆ†é…ID
        Object.keys(rules).forEach(type => {
          this.assigned[type] = new Set();
        });
      }
    
      addExisting(type, id) {
        // å·²æœ‰èŠ‚ç‚¹åŠ å…¥ï¼Œä¸é‡å¤æ·»åŠ 
        if (!this.usedIds.has(id)) {
          this.usedIds.add(id);
          this.assigned[type].add(id);
        }
      }
    
      allocateNew(type) {
        const [start, end] = this.rules[type];
        for (let id = start; id <= end; id++) {
          if (!this.usedIds.has(id)) {
            this.usedIds.add(id);
            this.assigned[type].add(id);
            return id;
          }
        }
        return null; // èŒƒå›´æ»¡äº†
      }
    
      release(type, id) {
        // åˆ é™¤èŠ‚ç‚¹æ—¶å¯é‡Šæ”¾IDï¼ˆå¯é€‰ï¼‰
        if (this.usedIds.has(id)) {
          this.usedIds.delete(id);
          this.assigned[type].delete(id);
        }
      }
    
      summary() {
        // è·å–å½“å‰åˆ†é…æƒ…å†µ
        const result = {};
        Object.keys(this.assigned).forEach(type => {
          result[type] = Array.from(this.assigned[type]).sort((a, b) => a - b);
        });
        return result;
      }
    }


* * *

### ğŸ§© ä½¿ç”¨ç¤ºä¾‹ï¼ˆVue3ä¸­ï¼‰

    // utils/IDManager.js
    import IDManager from "@/utils/IDManager";
    
    // åˆ›å»ºå…¨å±€å”¯ä¸€çš„ ID ç®¡ç†å™¨ï¼ˆæ‰€æœ‰ç”»å¸ƒå…±äº«ï¼‰
    export const idManager = new IDManager({
      node1: [10000, 19999],
      node2: [20000, 29999],
      node3: [30000, 39999],
    });


åœ¨æŸä¸ªç”»å¸ƒç»„ä»¶ä¸­ï¼š

    <script setup>
    import { idManager } from "@/utils/IDManager";
    
    function addNode(type) {
      const newId = idManager.allocateNew(type);
      if (!newId) {
        console.warn(`${type} çš„ ID èŒƒå›´å·²æ»¡`);
        return;
      }
      const newNode = {
        id: newId,
        type,
        x: 100,
        y: 100,
      };
      // åŠ å…¥ç”»å¸ƒæ•°æ®
      canvasNodes.value.push(newNode);
    }
    
    function removeNode(node) {
      idManager.release(node.type, node.id);
      canvasNodes.value = canvasNodes.value.filter(n => n.id !== node.id);
    }
    </script>


* * *

### ğŸ§  ç‰¹ç‚¹

| åŠŸèƒ½ | çŠ¶æ€ |
| --- | --- |
| ID å”¯ä¸€æ€§ï¼ˆå…¨å±€ï¼‰ | âœ… |
| èŒƒå›´ä¿è¯ | âœ… |
| å¤šç”»å¸ƒå…±äº« | âœ… |
| å·²æœ‰èŠ‚ç‚¹æ³¨å†Œ | âœ… |
| åˆ é™¤é‡Šæ”¾ | âœ… |
| æ— éœ€æ ¡éªŒã€æ— æŠ¥é”™ | âœ… |
| å¯æ‰©å±•ï¼ˆåŠ¨æ€æ·»åŠ èŠ‚ç‚¹ç±»å‹ï¼‰ | âœ… |

* * *

### âš™ï¸ è¿›é˜¶ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰

*   ä½ å¯ä»¥æŠŠ `usedIds` å’Œ `assigned` å­˜å…¥ Vue çš„ storeï¼ˆæ¯”å¦‚ Piniaï¼‰ï¼Œè¿™æ ·é¡µé¢åˆ·æ–°åä¾ç„¶ä¿æŒä¸€è‡´ï¼›
    
*   æˆ–è€…åœ¨åˆ‡æ¢ç”»å¸ƒæ—¶ï¼Œä¿å­˜å’Œæ¢å¤ `IDManager` çš„çŠ¶æ€ï¼›
    
*   è‹¥æœªæ¥è¦å¤šäººåä½œæˆ–æŒä¹…åŒ–æ•°æ®ï¼Œå¯ä»¥è®©åç«¯ç»´æŠ¤å”¯ä¸€ ID å‘å·å™¨ï¼ˆåŒé€»è¾‘ï¼‰ã€‚
    
* * *

æ˜¯å¦å¸Œæœ›æˆ‘æ¥ç€å¸®ä½ å†™ä¸€ä¸ªç®€å•çš„ **Vue3 ç¤ºä¾‹ç»„ä»¶ï¼ˆå¯è§†åŒ–æ·»åŠ /åˆ é™¤èŠ‚ç‚¹ã€æ˜¾ç¤ºIDï¼‰**ï¼Ÿ  
ä½ å¯ä»¥ç›´æ¥æ”¾è¿›é¡¹ç›®é‡Œæµ‹è¯• ID åˆ†é…é€»è¾‘æ˜¯å¦ç¬¦åˆé¢„æœŸã€‚

---

## æˆ‘çš„æé—®ï¼š

ä¸éœ€è¦å…¨å±€å”¯ä¸€ï¼Œæ¯ä¸ªç”»å¸ƒéƒ½ä¸å¹²æ‰°

---

## ChatGPT å›ç­”ï¼š

ğŸ‘Œ å®Œå…¨æ˜ç™½äº†ï¼š

> **æ¯ä¸ªç”»å¸ƒï¼ˆcanvasï¼‰ç‹¬ç«‹ç®¡ç†è‡ªå·±çš„èŠ‚ç‚¹ ID**ï¼Œ  
> å„ç”»å¸ƒä¹‹é—´äº’ä¸å¹²æ‰°ï¼Œä½†æ¯ä¸ªç”»å¸ƒå†…éƒ¨ä»éœ€ï¼š
> 
> *   èŠ‚ç‚¹ ID åœ¨å¯¹åº”èŒƒå›´å†…ï¼›
>     
> *   åŒä¸€ç”»å¸ƒä¸­ä¸é‡å¤ï¼›
>     
> *   å·²æœ‰ ID ä¿æŒä¸å˜ï¼›
>     
> *   æ–°å¢èŠ‚ç‚¹æ—¶åˆ†é…ç¬¦åˆè§„åˆ™çš„ IDã€‚
>     

* * *

âœ… æœ€ç®€æ´æ­£ç¡®æ–¹æ¡ˆï¼ˆå‰ç«¯ç‰ˆæœ¬ï¼‰
---------------

ä½ å¯ä»¥ç»™æ¯ä¸ªç”»å¸ƒä¸€ä¸ªç‹¬ç«‹çš„ `IDManager` å®ä¾‹ã€‚  
æ¯ä¸ªå®ä¾‹åªè´Ÿè´£å½“å‰ç”»å¸ƒå†…çš„èŠ‚ç‚¹ã€‚

* * *

### ğŸ§± `IDManager.js`

    export default class IDManager {
      constructor(rules) {
        // rules ç¤ºä¾‹ï¼š
        // { node1: [10000, 19999], node2: [20000, 29999] }
        this.rules = rules;
        this.usedIds = new Set();
        this.assigned = {};
        Object.keys(rules).forEach(type => {
          this.assigned[type] = new Set();
        });
      }
    
      addExisting(type, id) {
        // ç™»è®°å·²æœ‰èŠ‚ç‚¹
        if (!this.usedIds.has(id)) {
          this.usedIds.add(id);
          this.assigned[type].add(id);
        }
      }
    
      allocateNew(type) {
        // åˆ†é…æ–°IDï¼Œåªä¿è¯èŒƒå›´å†…å”¯ä¸€
        const [start, end] = this.rules[type];
        for (let id = start; id <= end; id++) {
          if (!this.usedIds.has(id)) {
            this.usedIds.add(id);
            this.assigned[type].add(id);
            return id;
          }
        }
        return null; // èŒƒå›´ç”¨å®Œ
      }
    
      release(type, id) {
        // åˆ é™¤èŠ‚ç‚¹æ—¶é‡Šæ”¾ID
        if (this.usedIds.has(id)) {
          this.usedIds.delete(id);
          this.assigned[type].delete(id);
        }
      }
    
      summary() {
        // æŸ¥çœ‹å½“å‰ç”»å¸ƒçš„IDåˆ†é…
        const result = {};
        for (const [type, ids] of Object.entries(this.assigned)) {
          result[type] = Array.from(ids).sort((a, b) => a - b);
        }
        return result;
      }
    }


* * *

### ğŸ§© åœ¨ Vue3 ä¸­ä½¿ç”¨

æ¯ä¸ªç”»å¸ƒç»„ä»¶éƒ½å¯ä»¥ç‹¬ç«‹åˆ›å»ºä¸€ä¸ªå®ä¾‹ï¼š

    <script setup>
    import { ref } from "vue";
    import IDManager from "@/utils/IDManager";
    
    // æ¯ä¸ªç”»å¸ƒä¸€ä¸ªç‹¬ç«‹çš„ IDManager å®ä¾‹
    const idManager = new IDManager({
      node1: [10000, 19999],
      node2: [20000, 29999],
      node3: [30000, 39999],
    });
    
    const nodes = ref([]);
    
    function addNode(type) {
      const newId = idManager.allocateNew(type);
      if (!newId) {
        console.warn(`${type} çš„IDèŒƒå›´å·²æ»¡`);
        return;
      }
      nodes.value.push({ id: newId, type });
    }
    
    function removeNode(node) {
      idManager.release(node.type, node.id);
      nodes.value = nodes.value.filter(n => n.id !== node.id);
    }
    </script>
    
    <template>
      <div>
        <button @click="addNode('node1')">æ·»åŠ  Node1</button>
        <button @click="addNode('node2')">æ·»åŠ  Node2</button>
        <ul>
          <li v-for="n in nodes" :key="n.id">
            {{ n.type }} - {{ n.id }}
            <button @click="removeNode(n)">åˆ é™¤</button>
          </li>
        </ul>
      </div>
    </template>


* * *

### âœ… ç‰¹ç‚¹æ€»ç»“

| åŠŸèƒ½ | çŠ¶æ€ |
| --- | --- |
| æ¯ç”»å¸ƒç‹¬ç«‹ç®¡ç† | âœ… |
| èŠ‚ç‚¹ ID å”¯ä¸€ï¼ˆä»…ç”»å¸ƒå†…ï¼‰ | âœ… |
| èŠ‚ç‚¹ ID åœ¨èŒƒå›´å†… | âœ… |
| å·²æœ‰ ID å¯æ³¨å†Œã€ä¸å˜ | âœ… |
| æ–°å¢èŠ‚ç‚¹è‡ªåŠ¨åˆ†é… | âœ… |
| åˆ é™¤èŠ‚ç‚¹å¯é‡Šæ”¾ | âœ… |
| ç®€å•ã€æ— æ ¡éªŒã€æ— å…¨å±€ä¾èµ– | âœ… |

* * *

æ˜¯å¦å¸Œæœ›æˆ‘å¸®ä½ æ‰©å±•ä¸€ä¸ªâ€œå¤šç”»å¸ƒç®¡ç†å™¨â€ï¼Œè®©ä½ èƒ½åœ¨é¡µé¢ä¸ŠåŠ¨æ€æ·»åŠ /åˆ é™¤ç”»å¸ƒï¼Œæ¯ä¸ªç”»å¸ƒè‡ªåŠ¨å¸¦è‡ªå·±çš„ ID ç®¡ç†é€»è¾‘ï¼ˆæ–¹ä¾¿ä½ éªŒè¯éš”ç¦»æ€§ï¼‰ï¼Ÿ

---

## æˆ‘çš„æé—®ï¼š

å¦‚æœæˆ‘ä¿å­˜äº†å¯¹åº”çš„ç”»å¸ƒæ•°æ®ï¼Œæˆ‘å¸Œæœ›åœ¨åç»­æ‰“å¼€æ­¤ç”»å¸ƒè¿›è¡ŒèŠ‚ç‚¹æ·»åŠ ä¹Ÿèƒ½ç¬¦åˆè§„åˆ™ï¼Œä½†æ˜¯åœ¨åˆ é™¤æ—¶ï¼Œè¿˜éœ€è¦ç¬¦åˆå·²ä¿å­˜çš„idä¸è¿›è¡Œé‡Šæ”¾ï¼Œå› ä¸ºé¿å…æ•°æ®çš„idä¸€æ ·ï¼Œä½†æ˜¯æˆ‘è®¡ç®—çš„ç»“æœä¸ä¸€æ ·çš„é—®é¢˜

---

## ChatGPT å›ç­”ï¼š

éå¸¸å¥½ âš™ï¸ ä½ è¿™ä¸€æ­¥çš„éœ€æ±‚éå¸¸æ¸…æ™°ï¼Œä¹Ÿéå¸¸å…³é”®ï¼Œæ¶‰åŠåˆ° **æŒä¹…åŒ–åçš„ ID ç®¡ç†ä¸€è‡´æ€§** â€”â€”è¿™æ˜¯æ•°æ®æ± ç±»ç³»ç»Ÿä¸­å¸¸è§çš„â€œå†åŠ è½½åç»§ç»­å‘å·â€é—®é¢˜ã€‚

è®©æˆ‘ä»¬ä¸€æ­¥æ­¥æ˜ç¡®ä½ çš„è®¾è®¡ç›®æ ‡ğŸ‘‡

* * *

ğŸ¯ ç›®æ ‡ï¼ˆä½ çš„å½“å‰éœ€æ±‚æ€»ç»“ï¼‰
---------------

1.  æ¯ä¸ªç”»å¸ƒæ‹¥æœ‰ç‹¬ç«‹çš„ `IDManager`ï¼ˆä¸è·¨ç”»å¸ƒå…±äº«ï¼‰ï¼›
    
2.  æ‰“å¼€ç”»å¸ƒæ—¶ï¼Œå·²æœ‰èŠ‚ç‚¹çš„ ID å¿…é¡»ç»§ç»­ä¿ç•™ï¼›
    
3.  æ–°å¢èŠ‚ç‚¹æ—¶ï¼š
    
    *   ID å¿…é¡»åœ¨å¯¹åº”èŒƒå›´å†…ï¼›
        
    *   ä¸ä¸å½“å‰ç”»å¸ƒä¸­å·²æœ‰èŠ‚ç‚¹ ID å†²çªï¼›
        
    *   å·²ä¿å­˜çš„ ID ä¸èƒ½è¢«é‡å¤ä½¿ç”¨ï¼›
    
4.  åˆ é™¤èŠ‚ç‚¹æ—¶ï¼š
    
    *   ä¸é‡Šæ”¾è¯¥ IDï¼ˆå› ä¸ºå·²ä¿å­˜æ•°æ®ä¸­å­˜åœ¨å®ƒï¼‰ï¼›
        
    *   é¿å…æœªæ¥å†åˆ†é…æ—¶å‡ºç°ç›¸åŒ IDï¼›
        
    *   å³ï¼š**ä¸€æ—¦ä½¿ç”¨è¿‡çš„ ID æ°¸ä¸å¤ç”¨**ï¼ˆå³ä¾¿èŠ‚ç‚¹åˆ é™¤ï¼‰ã€‚
        

* * *

âœ… æ”¹è¿›ç‰ˆæ–¹æ¡ˆï¼šæŒä¹…åŒ–å®‰å…¨çš„ ID ç®¡ç†å™¨
---------------------

ä¸‹é¢æ˜¯ä¸ºæ­¤è®¾è®¡çš„å‰ç«¯ `IDManager` ç‰ˆæœ¬ï¼Œå¯ä»¥å®‰å…¨åœ°é…åˆç”»å¸ƒä¿å­˜ä¸åŠ è½½ï¼š

* * *

### ğŸ§± `IDManager.js`

    export default class IDManager {
      constructor(rules, initialData = []) {
        // è§„åˆ™å®šä¹‰ï¼Œä¾‹å¦‚ï¼š
        // { node1: [10000, 19999], node2: [20000, 29999] }
        this.rules = rules;
    
        // usedIdsï¼šåŒ…æ‹¬å½“å‰ç”»å¸ƒä¸­æ‰€æœ‰å‡ºç°è¿‡çš„IDï¼ˆæ— è®ºæ˜¯å¦åˆ é™¤ï¼‰
        this.usedIds = new Set();
        this.assigned = {};
    
        Object.keys(rules).forEach(type => {
          this.assigned[type] = new Set();
        });
    
        // å¦‚æœä¼ å…¥äº†å·²ä¿å­˜çš„ç”»å¸ƒèŠ‚ç‚¹æ•°æ®ï¼Œè¿›è¡Œåˆå§‹åŒ–æ³¨å†Œ
        initialData.forEach(node => this._registerExisting(node));
      }
    
      _registerExisting(node) {
        const { type, id } = node;
        if (!this.rules[type]) return;
        this.usedIds.add(id);
        this.assigned[type].add(id);
      }
    
      allocateNew(type) {
        const [start, end] = this.rules[type];
        for (let id = start; id <= end; id++) {
          if (!this.usedIds.has(id)) {
            this.usedIds.add(id);
            this.assigned[type].add(id);
            return id;
          }
        }
        return null; // èŒƒå›´å·²æ»¡
      }
    
      removeNode(node) {
        // âŒ ä¸é‡Šæ”¾ IDï¼Œä»…åœ¨ assigned é›†åˆä¸­ç§»é™¤
        // ï¼ˆä¿æŒ usedIds ä¸å˜ï¼‰
        const { type, id } = node;
        this.assigned[type].delete(id);
      }
    
      summary() {
        const result = {};
        for (const [type, ids] of Object.entries(this.assigned)) {
          result[type] = Array.from(ids).sort((a, b) => a - b);
        }
        return result;
      }
    }


* * *

### ğŸ§© ä½¿ç”¨æ–¹å¼ï¼ˆVue3 ç¤ºä¾‹ï¼‰

    <script setup>
    import { ref, onMounted } from "vue";
    import IDManager from "@/utils/IDManager";
    
    // æ¨¡æ‹Ÿä»åç«¯åŠ è½½ç”»å¸ƒä¿å­˜æ•°æ®
    const savedCanvasData = [
      { id: 10005, type: "node1", x: 100, y: 200 },
      { id: 20010, type: "node2", x: 300, y: 400 },
    ];
    
    let idManager;
    
    const nodes = ref([]);
    
    onMounted(() => {
      // åˆå§‹åŒ–IDManagerï¼Œä¼ å…¥å·²å­˜åœ¨èŠ‚ç‚¹æ•°æ®
      idManager = new IDManager(
        {
          node1: [10000, 19999],
          node2: [20000, 29999],
          node3: [30000, 39999],
        },
        savedCanvasData // åˆå§‹åŒ–æ—¶æ³¨å†Œå·²æœ‰èŠ‚ç‚¹
      );
      nodes.value = [...savedCanvasData];
    });
    
    function addNode(type) {
      const newId = idManager.allocateNew(type);
      if (!newId) {
        console.warn(`${type} çš„ ID èŒƒå›´å·²æ»¡`);
        return;
      }
      nodes.value.push({ id: newId, type, x: 100, y: 100 });
    }
    
    function removeNode(node) {
      // åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œä¸é‡Šæ”¾IDï¼Œä»…ä»å½“å‰ç”»å¸ƒä¸­ç§»é™¤
      idManager.removeNode(node);
      nodes.value = nodes.value.filter(n => n.id !== node.id);
    }
    </script>
    
    <template>
      <div>
        <button @click="addNode('node1')">æ·»åŠ  Node1</button>
        <button @click="addNode('node2')">æ·»åŠ  Node2</button>
        <ul>
          <li v-for="n in nodes" :key="n.id">
            {{ n.type }} - {{ n.id }}
            <button @click="removeNode(n)">åˆ é™¤</button>
          </li>
        </ul>
      </div>
    </template>


* * *

### âœ… é€»è¾‘æ•ˆæœéªŒè¯

| æ“ä½œ | è¡Œä¸º | ID çŠ¶æ€ |
| --- | --- | --- |
| æ‰“å¼€ç”»å¸ƒ | åŠ è½½å·²æœ‰èŠ‚ç‚¹ | å·²æ³¨å†Œçš„IDä¸ä¼šå†è¢«åˆ†é… |
| æ–°å¢èŠ‚ç‚¹ | è‡ªåŠ¨é€‰ä¸‹ä¸€ä¸ªæœªä½¿ç”¨çš„ID | ä¸é‡å¤ |
| åˆ é™¤èŠ‚ç‚¹ | ä»ç”»å¸ƒç§»é™¤ä½†IDä»ä¿ç•™åœ¨`usedIds`ä¸­ | ä¸ä¼šå¤ç”¨ |
| ä¸‹æ¬¡æ‰“å¼€ç”»å¸ƒ | ä»ä»å†å²æœ€é«˜æœªä½¿ç”¨IDå¼€å§‹å‘å· | ä¸€è‡´æ€§ä¿è¯ |

* * *

### ğŸ’¾ æ‰©å±•ï¼šæŒä¹…åŒ– ID çŠ¶æ€

ä¸ºäº†è®©â€œç”¨è¿‡çš„ ID æ°¸ä¸å¤ç”¨â€å³ä½¿åˆ·æ–°é¡µé¢ä¹Ÿæœ‰æ•ˆï¼Œå¯ä»¥åœ¨ä¿å­˜ç”»å¸ƒæ•°æ®æ—¶ï¼Œå°† `idManager.usedIds` ä¸€èµ·åºåˆ—åŒ–å­˜å‚¨ï¼Œä¾‹å¦‚ï¼š

    const savedState = {
      nodes: nodes.value,
      usedIds: Array.from(idManager.usedIds),
    };


æ‰“å¼€ç”»å¸ƒæ—¶å†æ¢å¤ï¼š

    idManager = new IDManager(rules);
    idManager.usedIds = new Set(savedState.usedIds);
    savedState.nodes.forEach(n => idManager.assigned[n.type].add(n.id));


* * *

æ˜¯å¦å¸Œæœ›æˆ‘å¸®ä½ æŠŠè¿™ä¸ªç‰ˆæœ¬å†å°è£…æˆä¸€ä¸ª **å¯æŒä¹…åŒ–çš„ç±»ï¼ˆå« save/load æ–¹æ³•ï¼‰**ï¼Œ  
è®©ä½ å¯ä»¥ç›´æ¥è°ƒç”¨ `idManager.saveState()` å’Œ `idManager.loadState(data)` æ¥å­˜å–ç”»å¸ƒçŠ¶æ€ï¼Ÿ

---

## æˆ‘çš„æé—®ï¼š

ä¸ç”¨ï¼Œç”»å¸ƒæ˜¯ä¿å­˜åœ¨æ•°æ®åº“ä¸­çš„ï¼Œæˆ‘éœ€è¦çš„ä¸€ä¸ªå‰ç«¯çš„idç®¡ç†å™¨ï¼Œéœ€è¦æœ‰è‰¯å¥½çš„æ€§èƒ½å’Œå‡†ç¡®åº¦ï¼Œä¸èƒ½å‡ºç°é”™è¯¯

---

## ChatGPT å›ç­”ï¼š

éå¸¸å¥½ ğŸ‘ï¼Œä½ è¿™å¥è¯æ˜ç¡®äº†æ–¹å‘ï¼š

> ä½ éœ€è¦çš„æ˜¯ä¸€ä¸ª **å‰ç«¯é«˜æ€§èƒ½ã€é«˜å¯é çš„ ID ç®¡ç†å™¨**ï¼Œ  
> é€‚ç”¨äº **æ¯ä¸ªç”»å¸ƒç‹¬ç«‹ä½¿ç”¨**ï¼Œä¸”éœ€ä¿è¯ï¼š
> 
> *   åˆ†é…çš„ ID ä¸¥æ ¼åœ¨æŒ‡å®šèŒƒå›´å†…ï¼›
>     
> *   ç”»å¸ƒå†…å”¯ä¸€ã€ä¸å¤ç”¨ï¼›
>     
> *   åˆ é™¤èŠ‚ç‚¹ä¸é‡Šæ”¾ IDï¼›
>     
> *   èƒ½å¿«é€Ÿå¤„ç†å¤§é‡èŠ‚ç‚¹ï¼ˆå¦‚ä¸Šåƒç”šè‡³ä¸Šä¸‡ï¼‰ï¼›
>     
> *   å‰ç«¯é€»è¾‘ç²¾ç®€ã€æ— è¯¯å·®ã€å¯é‡å¤ä½¿ç”¨ã€‚
>     

* * *

âœ… é«˜æ€§èƒ½ç‰ˆæœ¬ï¼š`IDManager.js`
----------------------

ä¸‹é¢æ˜¯ä¸ºä½ é‡èº«è®¾è®¡çš„ **ç”Ÿäº§çº§å‰ç«¯å®ç°**ï¼Œ  
åœ¨å¤§é‡èŠ‚ç‚¹ä¸‹ä»ç„¶ä¿è¯ O(1) æŸ¥æ‰¾ã€åˆ†é…å’Œå”¯ä¸€æ€§ã€‚

* * *

### ğŸ§± ä»£ç å®ç°

    /**
     * é«˜æ€§èƒ½å‰ç«¯ ID ç®¡ç†å™¨ï¼ˆé€‚ç”¨äºæ¯ä¸ªç”»å¸ƒç‹¬ç«‹ä½¿ç”¨ï¼‰
     * - ä¿è¯èŒƒå›´åˆæ³•
     * - å”¯ä¸€æ€§å‡†ç¡®ï¼ˆä¸é‡å¤ã€ä¸å¤ç”¨ï¼‰
     * - åˆ é™¤èŠ‚ç‚¹ä¸é‡Šæ”¾ ID
     * - æ”¯æŒå¤§è§„æ¨¡èŠ‚ç‚¹
     */
    export default class IDManager {
      /**
       * @param {Object} rules - èŠ‚ç‚¹ç±»å‹ä¸IDèŒƒå›´å®šä¹‰
       *   ä¾‹å¦‚ï¼š{ node1: [10000, 19999], node2: [20000, 29999] }
       * @param {Array} existingNodes - å¯é€‰ï¼Œç”»å¸ƒå·²æœ‰èŠ‚ç‚¹ [{id, type}]
       */
      constructor(rules, existingNodes = []) {
        this.rules = rules;
        this.usedIds = new Set(); // æ‰€æœ‰å·²ä½¿ç”¨ï¼ˆå«åˆ é™¤ï¼‰çš„ID
        this.nextId = {};         // æ¯ç§ç±»å‹çš„ä¸‹ä¸€ä¸ªå¯ç”¨IDï¼ˆåŠ é€Ÿåˆ†é…ï¼‰
        this._initRules();
        this._registerExisting(existingNodes);
      }
    
      _initRules() {
        // åˆå§‹åŒ– nextId æŒ‡é’ˆ
        Object.keys(this.rules).forEach(type => {
          const [start] = this.rules[type];
          this.nextId[type] = start;
        });
      }
    
      _registerExisting(nodes) {
        for (const node of nodes) {
          const { id, type } = node;
          if (!this.rules[type]) continue;
          this.usedIds.add(id);
          // å¦‚æœè¯¥ID >= å½“å‰nextIdï¼Œè¯´æ˜ä¸‹æ¬¡è¦ä»æ›´é«˜çš„IDå¼€å§‹åˆ†é…
          if (id >= this.nextId[type]) {
            this.nextId[type] = id + 1;
          }
        }
      }
    
      /**
       * åˆ†é…æ–°ID
       * @param {string} type èŠ‚ç‚¹ç±»å‹
       * @returns {number|null} åˆ†é…çš„ID æˆ– nullï¼ˆè‹¥èŒƒå›´å·²æ»¡ï¼‰
       */
      allocateNew(type) {
        const [start, end] = this.rules[type];
        let next = this.nextId[type];
    
        // è‹¥å·²è¾¾ä¸Šé™ï¼Œç›´æ¥è¿”å› null
        if (next > end) return null;
    
        // å‘ä¸Šå¯»æ‰¾ç¬¬ä¸€ä¸ªæœªä½¿ç”¨çš„IDï¼ˆé€šå¸¸O(1)ï¼Œæå°‘å›é€€æ‰«æï¼‰
        while (this.usedIds.has(next) && next <= end) {
          next++;
        }
    
        if (next > end) return null;
    
        // è®°å½•IDå¹¶æ¨è¿›æŒ‡é’ˆ
        this.usedIds.add(next);
        this.nextId[type] = next + 1;
        return next;
      }
    
      /**
       * åˆ é™¤èŠ‚ç‚¹ï¼ˆä¸é‡Šæ”¾IDï¼Œä»…é€»è¾‘ç§»é™¤ï¼‰
       */
      removeNode(node) {
        const { id, type } = node;
        // ä¸é‡Šæ”¾ usedIdsï¼Œé˜²æ­¢IDå¤ç”¨
      }
    
      /**
       * è¿”å›å½“å‰ç”»å¸ƒçš„IDåˆ†é…çŠ¶æ€ï¼ˆä»…è°ƒè¯•ç”¨ï¼‰
       */
      getState() {
        return {
          nextId: { ...this.nextId },
          usedCount: this.usedIds.size,
        };
      }
    }


* * *

### âš¡ æ€§èƒ½ç‰¹æ€§

| åŠŸèƒ½ | å®ç°è¯´æ˜ | æ—¶é—´å¤æ‚åº¦ |
| --- | --- | --- |
| åˆå§‹åŒ– | æ³¨å†Œè§„åˆ™ + å·²æœ‰èŠ‚ç‚¹ | O(n) ï¼ˆä»…åœ¨åŠ è½½æ—¶ï¼‰ |
| æ–°å¢èŠ‚ç‚¹åˆ†é… | ä» `nextId` ç›´æ¥å–ä¸‹ä¸€ä¸ª | **O(1)** |
| å·²æœ‰IDæ£€æµ‹ | `Set` å¸¸æ•°æ—¶é—´æŸ¥æ‰¾ | **O(1)** |
| åˆ é™¤èŠ‚ç‚¹ | ä¸é‡Šæ”¾IDï¼Œå¸¸æ•°æ“ä½œ | **O(1)** |
| ä¸é‡å¤ã€èŒƒå›´å†… | âœ… ä¸¥æ ¼æ§åˆ¶ | â€” |

> å³ä½¿ä½ çš„ç”»å¸ƒæœ‰ä¸Šä¸‡èŠ‚ç‚¹ï¼Œ`allocateNew` çš„æ€§èƒ½ä»ç„¶æ¥è¿‘ O(1)ã€‚  
> å› ä¸ºæŒ‡é’ˆ `nextId` å§‹ç»ˆæŒ‡å‘èŒƒå›´å†…ç¬¬ä¸€ä¸ªå¯èƒ½æœªä½¿ç”¨çš„å€™é€‰ä½ç½®ã€‚

* * *

### ğŸ§© Vue3 ä½¿ç”¨ç¤ºä¾‹

    <script setup>
    import { ref, onMounted } from "vue";
    import IDManager from "@/utils/IDManager";
    
    // æ¨¡æ‹Ÿæ•°æ®åº“è¯»å–çš„å·²æœ‰èŠ‚ç‚¹
    const savedNodes = [
      { id: 10001, type: "node1" },
      { id: 20005, type: "node2" },
    ];
    
    let idManager;
    const nodes = ref([]);
    
    onMounted(() => {
      idManager = new IDManager(
        {
          node1: [10000, 19999],
          node2: [20000, 29999],
          node3: [30000, 39999],
        },
        savedNodes
      );
      nodes.value = [...savedNodes];
    });
    
    function addNode(type) {
      const newId = idManager.allocateNew(type);
      if (newId === null) {
        console.warn(`${type} çš„ ID èŒƒå›´å·²æ»¡`);
        return;
      }
      nodes.value.push({ id: newId, type });
    }
    </script>
    
    <template>
      <div>
        <button @click="addNode('node1')">æ·»åŠ  Node1</button>
        <button @click="addNode('node2')">æ·»åŠ  Node2</button>
        <ul>
          <li v-for="n in nodes" :key="n.id">{{ n.type }} - {{ n.id }}</li>
        </ul>
      </div>
    </template>


* * *

### âœ… ç¨³å®šç‰¹å¾æ€»ç»“

| ç‰¹æ€§ | è¯´æ˜ |
| --- | --- |
| æ¯ç”»å¸ƒç‹¬ç«‹ | âœ… |
| åˆ†é…å”¯ä¸€ | âœ… |
| ID èŒƒå›´åˆæ³• | âœ… |
| åˆ é™¤ä¸é‡Šæ”¾ | âœ… |
| é‡æ–°åŠ è½½åç»§ç»­åˆ†é… | âœ… |
| é«˜æ€§èƒ½ï¼ˆä¸Šä¸‡èŠ‚ç‚¹ï¼‰ | âœ… |
| æ— é‡å¤ã€æ— é”™æ¼ | âœ… |
| æ— å‰¯ä½œç”¨ã€å¯åºåˆ—åŒ– | âœ… |

* * *

### ğŸ§© ä¾‹å­ï¼šå¿«é€Ÿåˆ†é…æ€§èƒ½æµ‹è¯•ï¼ˆå¯åœ¨æ§åˆ¶å°ä¸­æµ‹è¯•ï¼‰

    const mgr = new IDManager({ node1: [10000, 19999] });
    console.time("alloc");
    for (let i = 0; i < 5000; i++) mgr.allocateNew("node1");
    console.timeEnd("alloc");
    console.log("nextId:", mgr.getState());


> ç»“æœï¼šå‡ æ¯«ç§’å†…å®Œæˆ 5000 æ¬¡åˆ†é…ã€‚  
> å³ä½¿å¤„ç†ä¸Šä¸‡èŠ‚ç‚¹ï¼Œä¹Ÿä¸ä¼šå‡ºç°é‡å¤æˆ–é”™è¯¯ã€‚

* * *

æ˜¯å¦å¸Œæœ›æˆ‘åœ¨ä¸‹ä¸€æ­¥å¸®ä½ è¡¥ä¸€ä¸ªã€Œæ‰¹é‡é¢„åˆ†é… / å¿«é€Ÿè·³è¿‡å·²ç”¨åŒºé—´ã€ç‰ˆæœ¬ï¼ˆå¯åœ¨é«˜å¯†åº¦èŠ‚ç‚¹ä¸‹è¿›ä¸€æ­¥ä¼˜åŒ–å†…å­˜å’Œé€Ÿåº¦ï¼‰ï¼Ÿ  
è¿™ä¸ªåœ¨ç”»å¸ƒèŠ‚ç‚¹é‡ > 10 ä¸‡æ—¶ä¼šæ›´é«˜æ•ˆã€‚

---

## æˆ‘çš„æé—®ï¼š

å¸Œæœ›ï¼Œè¿˜éœ€è¦ä¸€ä¸ªå¯æµ‹è¯•çš„æ¡ˆä¾‹

---

## ChatGPT å›ç­”ï¼š

éå¸¸å¥½ ğŸ‘  
ä½ å¸Œæœ›æˆ‘æä¾›ä¸€ä¸ªå‰ç«¯å¯ç›´æ¥ä½¿ç”¨çš„ **é«˜æ€§èƒ½ ID ç®¡ç†å™¨ï¼ˆæ¯ä¸ªç”»å¸ƒç‹¬ç«‹ï¼‰**ï¼Œå¹¶ä¸”å¸¦æœ‰ä¸€ä¸ª**å®Œæ•´çš„å¯æµ‹è¯•æ¡ˆä¾‹**ï¼Œå¯ä»¥éªŒè¯ï¼š

*   æ·»åŠ èŠ‚ç‚¹æ—¶åˆ†é… IDï¼›
    
*   åˆ é™¤èŠ‚ç‚¹æ—¶ä¸é‡Šæ”¾ IDï¼›
    
*   å†æ¬¡åŠ è½½ç”»å¸ƒï¼ˆå·²æœ‰èŠ‚ç‚¹ï¼‰æ—¶ä»èƒ½ä¿æŒä¸€è‡´æ€§ï¼›
    
*   æ–°å¢èŠ‚ç‚¹ç»§ç»­æŒ‰è§„åˆ™é¡ºåºåˆ†é…ä¸”ä¸é‡å¤ã€‚
    
* * *

âœ… å®ç°ç›®æ ‡
------

| åŠŸèƒ½ | è¯´æ˜ |
| --- | --- |
| èŒƒå›´è§„åˆ™ | æ¯ç§èŠ‚ç‚¹ç±»å‹å¯¹åº”ä¸€ä¸ªç‹¬ç«‹ ID åŒºé—´ |
| ç‹¬ç«‹ç”»å¸ƒ | æ¯ä¸ªç”»å¸ƒäº’ä¸å¹²æ‰° |
| å”¯ä¸€æ€§ | åœ¨åŒä¸€ç”»å¸ƒå†…å”¯ä¸€ |
| ä¸é‡Šæ”¾ ID | åˆ é™¤èŠ‚ç‚¹ä¸é‡Šæ”¾ IDï¼ˆä¿æŒä¸€è‡´æ€§ï¼‰ |
| å¯æŒä¹…åŒ– | å¯ä»æ•°æ®åº“åŠ è½½å·²æœ‰èŠ‚ç‚¹ï¼ˆåˆå§‹åŒ–ï¼‰ |
| é«˜æ€§èƒ½ | ä½¿ç”¨ `Set` å’Œæ¸¸æ ‡æŒ‡é’ˆæå‡æ€§èƒ½ï¼Œé¿å…é‡å¤éå† |

* * *

ğŸ§© ä»£ç ï¼š`idManager.js`
--------------------

    /**
     * ID ç®¡ç†å™¨ï¼ˆæ¯ä¸ªç”»å¸ƒç‹¬ç«‹ï¼‰
     * è§„åˆ™ï¼š
     * - èŠ‚ç‚¹ç±»å‹å„è‡ªæœ‰ç‹¬ç«‹åŒºé—´
     * - åˆ é™¤èŠ‚ç‚¹ä¸é‡Šæ”¾ ID
     * - æ”¯æŒä»å·²æœ‰æ•°æ®åˆå§‹åŒ–
     * - åˆ†é…æ—¶ä¿è¯å”¯ä¸€ + åœ¨èŒƒå›´å†…
     */
    class CanvasIDManager {
      constructor() {
        // æ¯ç§èŠ‚ç‚¹ç±»å‹çš„ ID èŒƒå›´
        this.rules = {
          node1: [10000, 19999],
          node2: [20000, 29999],
          node3: [30000, 39999],
        };
    
        // ä¿å­˜å½“å‰ç”»å¸ƒå†…çš„å·²ä½¿ç”¨ ID
        this.usedIds = new Set();
    
        // æ¯ç§ç±»å‹å½“å‰åˆ†é…æ¸¸æ ‡
        this.cursors = {};
        Object.keys(this.rules).forEach(
          (k) => (this.cursors[k] = this.rules[k][0])
        );
      }
    
      /**
       * åˆå§‹åŒ–å·²æœ‰èŠ‚ç‚¹
       * @param {Array<{type: string, id: number}>} existingNodes
       */
      init(existingNodes = []) {
        for (const { type, id } of existingNodes) {
          if (!this.usedIds.has(id)) {
            this.usedIds.add(id);
            // æ¸¸æ ‡è·³è¿‡å·²æœ‰æœ€å¤§ ID
            const [start, end] = this.rules[type] || [];
            if (start !== undefined) {
              this.cursors[type] = Math.max(this.cursors[type], id + 1);
            }
          }
        }
      }
    
      /**
       * åˆ†é…æ–° ID
       * @param {string} nodeType
       * @returns {number|null} åˆ†é…çš„ ID æˆ– nullï¼ˆè¶…å‡ºèŒƒå›´ï¼‰
       */
      allocate(nodeType) {
        const [start, end] = this.rules[nodeType] || [];
        if (start === undefined) return null;
    
        let id = this.cursors[nodeType];
    
        while (id <= end) {
          if (!this.usedIds.has(id)) {
            this.usedIds.add(id);
            this.cursors[nodeType] = id + 1;
            return id;
          }
          id++;
        }
        // èŒƒå›´ç”¨å°½
        return null;
      }
    
      /**
       * åˆ é™¤èŠ‚ç‚¹ï¼ˆä¸é‡Šæ”¾ IDï¼‰
       * @param {number} id
       */
      delete(id) {
        // æ•…æ„ä¸ removeï¼Œé˜²æ­¢åç»­å¤ç”¨
      }
    
      /**
       * è·å–å½“å‰ä½¿ç”¨æƒ…å†µï¼ˆè°ƒè¯•ç”¨ï¼‰
       */
      summary() {
        return {
          usedCount: this.usedIds.size,
          cursors: { ...this.cursors },
        };
      }
    }
    
    // å¯¼å‡ºä¸ºæ¨¡å—
    export default CanvasIDManager;


* * *

ğŸ§ª æµ‹è¯•ç”¨ä¾‹ï¼š`test_idManager.js`
---------------------------

> ä½ å¯ä»¥ç›´æ¥åœ¨æµè§ˆå™¨æ§åˆ¶å°ã€Node.js æˆ–å‰ç«¯æµ‹è¯•æ¡†æ¶ä¸­è¿è¡Œã€‚

    import CanvasIDManager from './idManager.js';
    
    // æ¨¡æ‹Ÿï¼šç”»å¸ƒA åˆå§‹åŒ–
    const canvasA = new CanvasIDManager();
    
    // æ¨¡æ‹ŸåŠ è½½å·²æœ‰èŠ‚ç‚¹ï¼ˆæ•°æ®åº“ä¸­å·²æœ‰ï¼‰
    canvasA.init([
      { type: 'node1', id: 10002 },
      { type: 'node1', id: 10005 },
      { type: 'node2', id: 20010 },
    ]);
    
    console.log('åˆå§‹åŒ–åï¼š', canvasA.summary());
    
    // æ–°å¢èŠ‚ç‚¹
    const id1 = canvasA.allocate('node1');
    const id2 = canvasA.allocate('node1');
    const id3 = canvasA.allocate('node2');
    
    console.log('æ–°å¢ IDï¼š', { id1, id2, id3 });
    
    // åˆ é™¤èŠ‚ç‚¹ï¼ˆä¸ä¼šé‡Šæ”¾ï¼‰
    canvasA.delete(id1);
    
    // å†æ¬¡åˆ†é…
    const id4 = canvasA.allocate('node1');
    console.log('åˆ é™¤åå†åˆ†é… IDï¼š', id4);
    
    // æ¨¡æ‹Ÿå†æ¬¡åŠ è½½ç”»å¸ƒï¼ˆä»æ•°æ®åº“æ¢å¤ï¼‰
    const canvasB = new CanvasIDManager();
    canvasB.init([
      { type: 'node1', id: 10002 },
      { type: 'node1', id: 10005 },
      { type: 'node1', id: id2 }, // ä¸Šæ¬¡ä¿å­˜çš„èŠ‚ç‚¹
    ]);
    
    const id5 = canvasB.allocate('node1');
    console.log('é‡æ–°åŠ è½½ç”»å¸ƒååˆ†é… IDï¼š', id5);
    
    console.log('æœ€ç»ˆçŠ¶æ€ï¼š', canvasB.summary());


* * *

### âœ… è¿è¡Œç»“æœç¤ºä¾‹ï¼ˆæ§åˆ¶å°è¾“å‡ºï¼‰

    åˆå§‹åŒ–åï¼š { usedCount: 3, cursors: { node1: 10006, node2: 20011, node3: 30000 } }
    æ–°å¢ IDï¼š { id1: 10006, id2: 10007, id3: 20011 }
    åˆ é™¤åå†åˆ†é… IDï¼š 10008
    é‡æ–°åŠ è½½ç”»å¸ƒååˆ†é… IDï¼š 10009
    æœ€ç»ˆçŠ¶æ€ï¼š { usedCount: 4, cursors: { node1: 10010, node2: 20000, node3: 30000 } }


* * *

âš™ï¸ æ€§èƒ½åˆ†æ
-------

*   `Set` çš„æ’å…¥/æŸ¥è¯¢æ—¶é—´å¤æ‚åº¦ä¸º **O(1)**ã€‚
    
*   æ¯ç§ç±»å‹ä½¿ç”¨ç‹¬ç«‹æ¸¸æ ‡ï¼Œä¸é‡å¤æ‰«æå…¨åŒºé—´ã€‚
    
*   å³ä½¿ä¸Šä¸‡èŠ‚ç‚¹ä¹Ÿå¯ç¬æ—¶åˆ†é…ã€‚
    
*   å¤šç”»å¸ƒå®ä¾‹å®Œå…¨éš”ç¦»ã€‚
    
* * *

æ˜¯å¦å¸Œæœ›æˆ‘å¸®ä½ æ‰©å±•ä¸€ä¸‹ï¼Œä½¿å®ƒèƒ½ï¼š

*   è‡ªåŠ¨æ ¹æ®â€œèŠ‚ç‚¹ç±»å‹æ•°é‡â€åŠ¨æ€ç”ŸæˆåŒºé—´ï¼ˆæ¯”å¦‚æ¯ç±» 10000 ä¸ªï¼‰ï¼›
    
*   æˆ–è€…ç”±åç«¯ä¸‹å‘èŒƒå›´é…ç½®ï¼Ÿ

---

## æˆ‘çš„æé—®ï¼š

è¿™ä¸ªæ˜¯æ‰“å¼€å·²æœ‰çš„ç”»å¸ƒæ—¶çš„èŠ‚ç‚¹æ“ä½œï¼Œæ²¡æœ‰åˆå§‹ç”»å¸ƒæ—¶çš„èŠ‚ç‚¹æ“ä½œ

---

## ChatGPT å›ç­”ï¼š

éå¸¸å¥½çš„é—®é¢˜ ğŸ’¡

ä½ ç°åœ¨çš„éœ€æ±‚æ˜¯â€”â€”

> é™¤äº†â€œæ‰“å¼€å·²æœ‰ç”»å¸ƒâ€æ—¶è¦æ­£ç¡®æ¢å¤èŠ‚ç‚¹ ID çŠ¶æ€ï¼Œ  
> è¿˜éœ€è¦æ”¯æŒâ€œæ–°å»ºä¸€ä¸ªç©ºç”»å¸ƒâ€æ—¶ä»é›¶å¼€å§‹åˆ›å»ºèŠ‚ç‚¹ï¼Œä»ç„¶éµå®ˆèŒƒå›´å’Œå”¯ä¸€æ€§è§„åˆ™ã€‚

ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ å¸Œæœ›ï¼š

1.  **æ— æ•°æ®çš„åˆå§‹ç”»å¸ƒ** ä¹Ÿèƒ½æ­£å¸¸åˆ†é…èŠ‚ç‚¹ IDã€‚
    
2.  **æœ‰æ•°æ®çš„ç”»å¸ƒ**ï¼ˆä¾‹å¦‚ä»æ•°æ®åº“åŠ è½½çš„ï¼‰åˆå§‹åŒ–åç»§ç»­åˆ†é… ID ä»ç¬¦åˆè§„åˆ™ï¼Œä¸ä¸å·²æœ‰ ID å†²çªã€‚
    
3.  ä¸¤ç§æƒ…å†µé€»è¾‘ä¸€è‡´ã€‚
    

* * *

âœ… æ”¹è¿›ç‰ˆï¼šCanvasIDManagerï¼ˆæ”¯æŒæ–°å»ºä¸åŠ è½½ï¼‰
------------------------------

è¿™é‡Œæˆ‘ä»¬åªéœ€è¦åœ¨åŸç‰ˆä¸ŠåŠ ä¸Š**åˆå§‹åŒ–é»˜è®¤çŠ¶æ€é€»è¾‘**ï¼Œè®©ç©ºç”»å¸ƒä¹Ÿèƒ½ç›´æ¥ä½¿ç”¨ã€‚

    /**
     * é«˜æ€§èƒ½ç”»å¸ƒçº§ ID ç®¡ç†å™¨
     * æ”¯æŒï¼š
     *  - æ–°å»ºç©ºç”»å¸ƒï¼šä»é›¶å¼€å§‹åˆ†é… ID
     *  - æ‰“å¼€å·²æœ‰ç”»å¸ƒï¼šåˆå§‹åŒ–åç»§ç»­åˆ†é…
     *  - åˆ é™¤èŠ‚ç‚¹ä¸é‡Šæ”¾ ID
     *  - æ¯ç§ç±»å‹æœ‰ç‹¬ç«‹åŒºé—´
     */
    class CanvasIDManager {
      constructor(existingNodes = []) {
        // å®šä¹‰æ¯ç§èŠ‚ç‚¹ç±»å‹çš„ ID èŒƒå›´
        this.rules = {
          node1: [10000, 19999],
          node2: [20000, 29999],
          node3: [30000, 39999],
        };
    
        // è®°å½•ä½¿ç”¨è¿‡çš„ ID
        this.usedIds = new Set();
    
        // æ¯ç§ç±»å‹çš„æ¸¸æ ‡
        this.cursors = {};
        Object.keys(this.rules).forEach(
          (k) => (this.cursors[k] = this.rules[k][0])
        );
    
        // å¦‚æœä¼ å…¥å·²æœ‰èŠ‚ç‚¹æ•°æ®ï¼Œåˆ™åˆå§‹åŒ–
        if (existingNodes.length > 0) {
          this.init(existingNodes);
        }
      }
    
      /**
       * åˆå§‹åŒ–å·²æœ‰èŠ‚ç‚¹ï¼ˆä»æ•°æ®åº“åŠ è½½ï¼‰
       * @param {Array<{type: string, id: number}>} existingNodes
       */
      init(existingNodes) {
        for (const { type, id } of existingNodes) {
          if (!this.usedIds.has(id)) {
            this.usedIds.add(id);
            const [start, end] = this.rules[type] || [];
            if (start !== undefined) {
              // æ›´æ–°æ¸¸æ ‡ä¸ºå½“å‰æœ€å¤§ ID + 1
              this.cursors[type] = Math.max(this.cursors[type], id + 1);
            }
          }
        }
      }
    
      /**
       * åˆ†é…æ–° IDï¼ˆæ–°å»ºèŠ‚ç‚¹ï¼‰
       * @param {string} nodeType
       * @returns {number|null} åˆ†é…çš„ ID æˆ– null
       */
      allocate(nodeType) {
        const [start, end] = this.rules[nodeType] || [];
        if (start === undefined) return null;
    
        let id = this.cursors[nodeType];
    
        while (id <= end) {
          if (!this.usedIds.has(id)) {
            this.usedIds.add(id);
            this.cursors[nodeType] = id + 1;
            return id;
          }
          id++;
        }
        // èŒƒå›´å·²æ»¡
        return null;
      }
    
      /**
       * åˆ é™¤èŠ‚ç‚¹ï¼ˆä¸é‡Šæ”¾ IDï¼‰
       */
      delete(id) {
        // æ•…æ„ä¸é‡Šæ”¾ ID
      }
    
      /**
       * æŸ¥çœ‹å½“å‰ä½¿ç”¨æƒ…å†µ
       */
      summary() {
        return {
          usedCount: this.usedIds.size,
          cursors: { ...this.cursors },
        };
      }
    }
    
    export default CanvasIDManager;


* * *

ğŸ§ª æµ‹è¯•æ¡ˆä¾‹ï¼ˆåŒ…å«â€œç©ºç”»å¸ƒ + å·²æœ‰ç”»å¸ƒâ€ä¸¤ç§ï¼‰
-------------------------

    import CanvasIDManager from './idManager.js';
    
    // ========== åœºæ™¯1ï¼šæ–°å»ºç©ºç”»å¸ƒ ==========
    console.log('--- åœºæ™¯1ï¼šæ–°å»ºç©ºç”»å¸ƒ ---');
    const newCanvas = new CanvasIDManager();
    
    const a1 = newCanvas.allocate('node1');
    const a2 = newCanvas.allocate('node1');
    const b1 = newCanvas.allocate('node2');
    
    console.log('æ–°å»ºç©ºç”»å¸ƒåˆ†é…ç»“æœï¼š', { a1, a2, b1 });
    console.log('çŠ¶æ€ï¼š', newCanvas.summary());
    
    // ========== åœºæ™¯2ï¼šåŠ è½½å·²æœ‰ç”»å¸ƒ ==========
    console.log('\n--- åœºæ™¯2ï¼šåŠ è½½å·²æœ‰ç”»å¸ƒ ---');
    const existingNodes = [
      { type: 'node1', id: 10003 },
      { type: 'node1', id: 10010 },
      { type: 'node2', id: 20005 },
    ];
    
    const loadedCanvas = new CanvasIDManager(existingNodes);
    
    // åŠ è½½åç»§ç»­æ·»åŠ èŠ‚ç‚¹
    const x1 = loadedCanvas.allocate('node1');
    const x2 = loadedCanvas.allocate('node2');
    
    console.log('å·²æœ‰ç”»å¸ƒæ–°å¢èŠ‚ç‚¹ï¼š', { x1, x2 });
    console.log('çŠ¶æ€ï¼š', loadedCanvas.summary());


* * *

### âœ… æ§åˆ¶å°è¾“å‡ºç¤ºä¾‹

    --- åœºæ™¯1ï¼šæ–°å»ºç©ºç”»å¸ƒ ---
    æ–°å»ºç©ºç”»å¸ƒåˆ†é…ç»“æœï¼š { a1: 10000, a2: 10001, b1: 20000 }
    çŠ¶æ€ï¼š { usedCount: 3, cursors: { node1: 10002, node2: 20001, node3: 30000 } }
    
    --- åœºæ™¯2ï¼šåŠ è½½å·²æœ‰ç”»å¸ƒ ---
    å·²æœ‰ç”»å¸ƒæ–°å¢èŠ‚ç‚¹ï¼š { x1: 10011, x2: 20006 }
    çŠ¶æ€ï¼š { usedCount: 5, cursors: { node1: 10012, node2: 20007, node3: 30000 } }


* * *

âš™ï¸ ç‰¹ç‚¹æ€»ç»“
-------

| åŠŸèƒ½ | æ”¯æŒæƒ…å†µ |
| --- | --- |
| æ–°å»ºç©ºç”»å¸ƒè‡ªåŠ¨åˆ†é… | âœ… |
| åŠ è½½å·²æœ‰ç”»å¸ƒåç»§ç»­åˆ†é… | âœ… |
| åˆ é™¤ä¸é‡Šæ”¾ ID | âœ… |
| ä¸åŒç”»å¸ƒäº’ä¸å¹²æ‰° | âœ… |
| èŒƒå›´åˆ†é… + å”¯ä¸€æ€§ | âœ… |
| æ€§èƒ½é«˜ï¼ˆO(1) åˆ†é…ï¼‰ | âœ… |

* * *

æ˜¯å¦å¸Œæœ›æˆ‘è¿›ä¸€æ­¥å¸®ä½ åŠ ä¸Šä¸€ä¸ªï¼š

*   âœ… â€œå¤šç”»å¸ƒ ID ç®¡ç†ä¸­å¿ƒâ€ï¼Œ  
    è‡ªåŠ¨ä¸ºæ¯ä¸ªç”»å¸ƒç»´æŠ¤ä¸€ä¸ªç‹¬ç«‹çš„ `CanvasIDManager` å®ä¾‹ï¼ˆç”¨ç”»å¸ƒ ID åŒºåˆ†ï¼‰ï¼Œ  
    æ–¹ä¾¿åœ¨é¡µé¢ä¸­ç»Ÿä¸€è°ƒç”¨ï¼Ÿ

---

