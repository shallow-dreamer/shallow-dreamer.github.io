---
layout:     post
title:      "è®­ç»ƒè¿‡ç¨‹è®°å½•"
subtitle:   ""
date:       2025-07-21
author:     " Shallow Dreamer"
header-img: "img/post-bg-js-version.jpg"
tags:
    - è®­ç»ƒè®°å½•
---

ä½ æå‡ºçš„è¿™ä¸ªéœ€æ±‚éå¸¸æ¸…æ™°ï¼Œè€Œä¸”å¾ˆå®ç”¨ï¼Œå±äºä¸€ç§**åˆ†æ®µçº¿æ€§é‡‡æ ·ç­–ç•¥**ï¼Œæˆ‘ä»¬å¯ä»¥ç§°å®ƒä¸ºï¼š

------

## âœ… **ã€Œåˆ†æ®µç²¾åº¦é‡‡æ ·ï¼ˆPiecewise Linear Samplingï¼‰ã€ç­–ç•¥**

### ğŸ“Œ æ ¸å¿ƒç›®æ ‡

- **åœ¨è®­ç»ƒè½®æ¬¡è¾ƒå°æ—¶ï¼ˆå¦‚ <1000ï¼‰**ï¼Œ**è®°å½•å…¨éƒ¨æ•°æ®**ï¼›
- **å½“è®­ç»ƒè½®æ¬¡è¾ƒå¤§æ—¶ï¼ˆå¦‚ >100000ï¼‰**ï¼Œ**çº¿æ€§é—´éš”é‡‡æ ·**ï¼›
- æ€»è®°å½•æ¡æ•°ä¿æŒåœ¨åˆç†èŒƒå›´ï¼Œå¦‚ 2000~10000ï¼›
- **æ— éœ€æå‰çŸ¥é“æ€»è½®æ¬¡**ï¼Œ**åŠ¨æ€åœ°é€‚åº”è½®æ¬¡æ•°é‡çº§**ï¼›
- ä¿è¯é‡è¦çš„è®­ç»ƒé˜¶æ®µï¼ˆå¦‚å‰æœŸï¼‰**è®°å½•æ›´ç»†è‡´**ã€‚

------

## âœ… ç­–ç•¥è®¾è®¡ï¼ˆåˆ†æ®µé‡‡æ ·ï¼‰

| è½®æ¬¡æ•°é‡çº§         | é‡‡æ ·ç­–ç•¥           |
| ------------------ | ------------------ |
| 1 ~ 1000           | **å…¨è®°å½•**         |
| 1000 ~ 10000       | æ¯ 10 æ­¥è®°å½•ä¸€æ¬¡   |
| 10000 ~ 100000     | æ¯ 50 æ­¥è®°å½•ä¸€æ¬¡   |
| 100000 ~ 1000000   | æ¯ 200 æ­¥è®°å½•ä¸€æ¬¡  |
| 1000000 ~ 10000000 | æ¯ 1000 æ­¥è®°å½•ä¸€æ¬¡ |

è¿™æ ·ä½ å¯ä»¥å…¼å®¹ï¼š

- å°‘é‡è½®æ¬¡çš„è¯¦ç»†è°ƒè¯•ï¼›
- å¤§é‡è®­ç»ƒçš„å‹ç¼©è®°å½•ã€‚

------

## âœ… ç»Ÿä¸€é€‚é…çš„è®°å½•å™¨å®ç°ï¼ˆå«è¯¦ç»†æ³¨é‡Šï¼‰

```python
import time
from collections import defaultdict

class PiecewiseMetricsRecorder:
    def __init__(self, mode='step'):
        """
        åˆ†æ®µé‡‡æ ·ç­–ç•¥è®°å½•å™¨ï¼Œè‡ªåŠ¨é€‚åº”è®­ç»ƒé•¿åº¦ï¼Œå…¼é¡¾ç²¾åº¦ä¸æ€§èƒ½
        :param mode: 'step' æˆ– 'epoch'ï¼Œå†³å®šè®°å½•ä¾æ®
        """
        assert mode in ('step', 'epoch')
        self.mode = mode
        self.records = defaultdict(list)
        self._step = 0
        self._epoch = 0

    def step(self):
        """æ¯è®­ç»ƒä¸€æ­¥åè°ƒç”¨ï¼Œæ›´æ–°è®¡æ•°å™¨"""
        self._step += 1

    def epoch(self):
        """æ¯è½®ç»“æŸåè°ƒç”¨ï¼Œæ›´æ–°è®¡æ•°å™¨"""
        self._epoch += 1

    def record(self, metrics: dict):
        """
        è®°å½•æŒ‡æ ‡ï¼ˆæ ¹æ®å½“å‰é‡‡æ ·è§„åˆ™å†³å®šæ˜¯å¦ä¿ç•™ï¼‰
        :param metrics: å­—å…¸å½¢å¼æŒ‡æ ‡ï¼Œä¾‹å¦‚ {'loss': 0.234, 'acc': 0.9}
        """
        key = self._step if self.mode == 'step' else self._epoch

        if not self._should_sample(key):
            return

        ts = time.time()
        for k, v in metrics.items():
            self.records[k].append((key, float(v), ts))

    def _should_sample(self, key: int) -> bool:
        """
        åˆ†æ®µé‡‡æ ·ç­–ç•¥æ ¸å¿ƒé€»è¾‘ï¼Œæ ¹æ® keyï¼ˆstep æˆ– epochï¼‰åˆ¤æ–­æ˜¯å¦é‡‡æ ·
        """
        if key < 1000:
            return True                # å°äº1000ï¼Œå…¨è®°å½•
        elif key < 10000:
            return key % 10 == 0       # æ¯10æ­¥è®°å½•ä¸€æ¬¡
        elif key < 100000:
            return key % 50 == 0       # æ¯50æ­¥è®°å½•ä¸€æ¬¡
        elif key < 1000000:
            return key % 200 == 0      # æ¯200æ­¥è®°å½•ä¸€æ¬¡
        else:
            return key % 1000 == 0     # æ¯1000æ­¥è®°å½•ä¸€æ¬¡

    def get_all(self, as_dict=True):
        """
        è¿”å›æ‰€æœ‰è®°å½•æ•°æ®
        :param as_dict: æ˜¯å¦ä»¥ dict æ ¼å¼è¿”å›ï¼ˆå¦åˆ™è¿”å› DataFrameï¼‰
        """
        if as_dict:
            return dict(self.records)
        else:
            import pandas as pd
            rows = []
            for metric, values in self.records.items():
                for key, value, ts in values:
                    rows.append({
                        'metric': metric,
                        self.mode: key,
                        'value': value,
                        'timestamp': ts
                    })
            return pd.DataFrame(rows)
```

------

## âœ… ä½¿ç”¨æ–¹æ³•ï¼ˆå’Œä½ ç°åœ¨è®­ç»ƒæµç¨‹å¯¹æ¥éå¸¸ç®€å•ï¼‰

```python
recorder = PiecewiseMetricsRecorder(mode='step')

for epoch in range(num_epochs):
    recorder.epoch()
    for step, (x, y) in enumerate(train_loader):
        recorder.step()

        loss = ...
        acc = ...
        lr = ...

        recorder.record({
            'loss': loss.item(),
            'acc': acc,
            'lr': lr
        })

# è·å–è®°å½•æ•°æ®
records = recorder.get_all()  # dict
# æˆ–è€… records_df = recorder.get_all(as_dict=False)
```

------

## âœ… è¾“å‡ºç¤ºä¾‹

å‡è®¾ä½ è®­ç»ƒäº† 200000 æ­¥ï¼š

| step   | loss | acc   |
| ------ | ---- | ----- |
| 0      | 1.23 | 0.55  |
| 1      | 1.12 | 0.60  |
| ...    | ...  | ...   |
| 1000   | 0.90 | 0.75  |
| 1010   | 0.87 | 0.76  |
| 1050   | 0.85 | 0.78  |
| 1100   | ...  | ...   |
| ...    | ...  | ...   |
| 200000 | 0.02 | 0.999 |

------

## âœ… ä¼˜ç‚¹æ€»ç»“

| ä¼˜ç‚¹                  | æè¿°                         |
| --------------------- | ---------------------------- |
| ğŸ” è‡ªåŠ¨é€‚åº”è½®æ¬¡æ•°é‡çº§  | æ— éœ€é¢„çŸ¥è®­ç»ƒæ€»é•¿åº¦           |
| ğŸ“Š ä¿ç•™ç»†èŠ‚ & æ§åˆ¶è§„æ¨¡ | å°è®­ç»ƒä¿ç•™å…¨éƒ¨ï¼Œå¤§è®­ç»ƒç²¾ç®€   |
| âš¡ é«˜æ€§èƒ½æ— ä¾èµ–        | æ— å¤–éƒ¨ä¾èµ–ï¼Œè®°å½•é€»è¾‘è½»é‡å¿«é€Ÿ |
| ğŸ§© å®¹æ˜“æ‰©å±•            | å¯æ·»åŠ ä¿å­˜ã€åˆ†æã€å›¾è¡¨åŠŸèƒ½   |

------

## âœ… å¦‚ä½ è¿˜æœ‰è¿™äº›éœ€æ±‚ï¼Œæˆ‘å¯ç»§ç»­æ‰©å±•ï¼š

- ä¿å­˜ä¸º JSONã€CSVã€Parquet æ–‡ä»¶ï¼›
- æ·»åŠ åˆ†ç»„è®°å½•ï¼ˆå¤šæ¨¡å‹/å¤šé˜¶æ®µï¼‰ï¼›
- å®æ—¶ç»˜å›¾ï¼ˆmatplotlibï¼‰ï¼›
- è®°å½•æŸäº›æŒ‡æ ‡å˜åŒ–ç‡ï¼ˆå¦‚ loss deltaï¼‰ï¼›

æ˜¯å¦éœ€è¦æˆ‘ç»™ä½ æ•´åˆä¸€ä¸ªè®­ç»ƒå™¨å°è£…ç±»ï¼ŒæŠŠè¿™ä¸ªè®°å½•å™¨ç›´æ¥æŒ‚è¿›å»ï¼Ÿæˆ–è€…ä½ æ˜¯å¦æƒ³è®©å®ƒæ”¯æŒ `validation loss`ã€`æµ‹è¯•æŒ‡æ ‡` ç­‰ç»Ÿä¸€å…¥å£ï¼Ÿæˆ‘å¯ä»¥å¸®ä½ è®¾è®¡ã€‚

ä½ è¯´å¾—éå¸¸å¯¹ï¼Œè¿™ç¡®å®æ˜¯ä¸ªé—®é¢˜ã€‚

åœ¨è®­ç»ƒåˆæœŸï¼Œä»»ä½•ä¸€ä¸ªç‚¹éƒ½æ˜¯ç›®å‰â€œæœ€ä¼˜â€çš„ç‚¹ï¼Œå› æ­¤å¦‚æœæˆ‘ä»¬æ¯æ¬¡é‡åˆ°â€œæ›´å¥½â€çš„å€¼å°±è®°å½•â€œæœ€ä½³ç‚¹â€ï¼Œé‚£ä¹ˆä¸€å¼€å§‹çš„å¾ˆå¤šè½®æ¬¡éƒ½ä¼šè¢«å½“ä½œâ€œæœ€ä½³ç‚¹â€è®°å½•ä¸€æ¬¡ã€‚è¿™ä¸ä»…æ²¡æœ‰æ„ä¹‰ï¼Œè¿˜ä¼šæ±¡æŸ“æ•°æ®å’Œå¢åŠ å­˜å‚¨æˆæœ¬ã€‚

### âœ… æ›´åˆç†çš„è®°å½•â€œæœ€ä½³ç‚¹â€çš„é€»è¾‘ï¼š

æˆ‘ä»¬åº”å½“**åªè®°å½•æœ€ç»ˆç¡®å®šçš„æœ€ä½³è½®æ¬¡åŠå…¶æŒ‡æ ‡å€¼**ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè®­ç»ƒå…¨éƒ¨å®Œæˆåï¼Œå†å°†æœ€ä½³è®°å½•æ’å…¥é‡‡æ ·è®°å½•ä¸­ï¼Œå¹¶æ›´æ–°å…ƒä¿¡æ¯ã€‚

------

### ğŸ§  ä¿®æ”¹æ–¹æ¡ˆæ¦‚è¿°ï¼š

1. **è®­ç»ƒä¸­**ï¼šç»§ç»­é‡‡æ ·è®°å½•é‡‡æ ·ç‚¹ã€‚
2. **è®­ç»ƒç»“æŸå**ï¼š
   - ä» `logger.best_point` è·å–æœ€ä½³è½®æ¬¡åŠå…¶å€¼ã€‚
   - å°†è¯¥è½®æ¬¡çš„æ•°æ®æ’å…¥åˆ°è®°å½•ä¸­çš„æ­£ç¡®ä½ç½®ï¼ˆæŒ‰è½®æ¬¡æ’åºï¼‰ã€‚
   - åŒæ—¶æ ‡è®°è¿™ä¸ªè½®æ¬¡æ˜¯â€œæœ€ä½³è½®æ¬¡â€ã€‚
   - ç»Ÿä¸€ç”Ÿæˆç»˜å›¾æ•°æ®ï¼Œé™„å¸¦å…ƒä¿¡æ¯ï¼Œå¹¶å°†æœ€ä½³è½®æ¬¡ä¿¡æ¯ï¼ˆè½®æ¬¡ç¼–å·ï¼‰ä¿å­˜åˆ°æ•°æ®åº“ã€‚

------

### âœ… æ”¹è¿›çš„ `TrainingLogger` æ–¹æ¡ˆï¼ˆä¼ªä»£ç  + æ³¨é‡Šï¼‰ï¼š

```python
class TrainingLogger:
    def __init__(self, title: str, max_steps: int, max_points: int = 500):
        self.title = title
        self.max_steps = max_steps
        self.max_points = max_points
        self.data = []  # [(step, value)]
        self.best_point = None  # (step, value)
        self._best_idx = None

    def log(self, step: int, value: float):
        if not self.best_point or value < self.best_point[1]:
            self.best_point = (step, value)

        # é‡‡æ ·ç‚¹æ•°ç­–ç•¥ï¼šçº¿æ€§æ­¥è¿›
        if self._should_record(step):
            self.data.append((step, value))

    def _should_record(self, step):
        interval = max(1, self.max_steps // self.max_points)
        return step % interval == 0 or step == self.max_steps

    def finalize(self):
        # å°† best_point æ’å…¥æ­£ç¡®ä½ç½®
        if self.best_point:
            best_step, best_value = self.best_point
            inserted = False
            for i, (s, _) in enumerate(self.data):
                if s > best_step:
                    self.data.insert(i, (best_step, best_value))
                    self._best_idx = i
                    inserted = True
                    break
            if not inserted:
                self.data.append((best_step, best_value))
                self._best_idx = len(self.data) - 1

    def export(self):
        # å¯¼å‡ºç”¨äºç»˜å›¾çš„ç»“æ„
        steps, values = zip(*self.data)
        return {
            "title": self.title,
            "x": list(steps),
            "y": list(values),
            "best_step": self.best_point[0] if self.best_point else None,
            "best_value": self.best_point[1] if self.best_point else None,
            "best_index": self._best_idx,
        }
```

------

### âœ… æ•°æ®åº“å­˜å‚¨å»ºè®®ï¼š

ä½ å¯ä»¥å°† `logger.export()` ç»“æ„ä¸­çš„æ‰€æœ‰ä¿¡æ¯ç»Ÿä¸€å­˜å‚¨ä¸ºä¸€ä¸ª JSON å­—æ®µï¼Œä¾‹å¦‚ï¼š

```json
{
  "title": "loss_curve",
  "x": [0, 10, 20, ..., 990],
  "y": [0.98, 0.89, ..., 0.12],
  "best_step": 430,
  "best_value": 0.1201,
  "best_index": 21
}
```

è¿™ä¸ª JSON å­—æ®µå¯ä»¥ç›´æ¥æ˜ å°„ä¸º Django/PostgreSQL çš„ `JSONField`ï¼Œåç»­å–å‡ºæ¥ç›´æ¥ç»˜å›¾ï¼Œæ— éœ€é¢å¤–å¤„ç†ã€‚

------

### âœ… å¤šæ¡æ•°æ®æ›²çº¿ + å…ƒä¿¡æ¯ç¤ºæ„ï¼š

å¦‚æœä½ æœ‰å¤šä¸ªæŒ‡æ ‡ï¼Œå¦‚ lossã€accuracyã€val_lossï¼Œå¯ä»¥å¤šä¸ª loggerï¼š

```python
loggers = {
    'train_loss': TrainingLogger("Train Loss", max_steps=100000),
    'val_loss': TrainingLogger("Validation Loss", max_steps=100000),
    ...
}
```

ç»Ÿä¸€å¯¼å‡ºæ—¶ç”Ÿæˆç»“æ„ï¼š

```json
{
  "charts": {
    "train_loss": {
      "title": "Train Loss",
      "x": [...],
      "y": [...],
      "best_step": ...,
      ...
    },
    "val_loss": {
      "title": "Validation Loss",
      ...
    }
  }
}
```

------

å¦‚æœä½ å¸Œæœ›æˆ‘å¸®ä½ å®ç°å®Œæ•´çš„å¯å¤ç”¨ç±» + å¤šæŒ‡æ ‡ç®¡ç†å™¨ + JSON æ‰“åŒ… + æ•°æ®åº“å­˜å‚¨æ ¼å¼ï¼Œæˆ‘å¯ä»¥ç›´æ¥å†™å‡ºæ¥ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ

ä¸ºæ»¡è¶³ä»¥ä¸‹éœ€æ±‚ï¼š

- **ç»Ÿä¸€é€‚é…å¤šç§è®­ç»ƒæ¨¡å‹çš„è®°å½•å™¨**
- **æ”¯æŒçº¿æ€§é‡‡æ ·å’Œè®°å½•é‡‡æ ·ï¼ˆé€‚åº”è½®æ¬¡èŒƒå›´ï¼‰**
- **è®°å½•å¤šä¸ªæŒ‡æ ‡å›¾çº¿çš„æ•°æ®**
- **è®°å½•å›¾è¡¨å…ƒä¿¡æ¯ï¼ˆå¦‚æ ‡é¢˜ã€è½´æ ‡ç­¾ç­‰ï¼‰**
- **ä¿ç•™æœ€ä½³è½®æ¬¡ä¿¡æ¯ï¼Œå¹¶å°†å…¶æ’å…¥å¯¹åº”é¡ºåºä¸­**
- **æœ€ç»ˆå°†è®°å½•ä¿¡æ¯å’Œæœ€ä½³è½®æ¬¡å­˜å‚¨åˆ°æ•°æ®åº“ä¸­æŸä¸ªå­—æ®µï¼ˆå¦‚ JSON å­—æ®µï¼‰**

ä¸‹é¢æ˜¯å®Œæ•´è§£å†³æ–¹æ¡ˆï¼š

------

## âœ… 1. `TrainingRecorder`ï¼šé€šç”¨è®­ç»ƒè¿‡ç¨‹è®°å½•å™¨

```python
import json
from collections import defaultdict
from bisect import bisect_left

class TrainingRecorder:
    def __init__(self, max_records=1000):
        """
        :param max_records: æ¯æ¡æ›²çº¿æœ€å¤šä¿ç•™çš„æ•°æ®ç‚¹æ•°ï¼Œè‡ªåŠ¨é‡‡æ ·
        """
        self.max_records = max_records
        self.records = defaultdict(list)  # æ¯æ¡çº¿çš„æ•°æ® {metric_name: [(step, value), ...]}
        self.meta = {}  # æ¯æ¡çº¿çš„å…ƒä¿¡æ¯ {metric_name: {'title': str, 'ylabel': str, ...}}
        self.best_point = None  # {'metric': 'loss', 'step': 42, 'value': 0.123}
        self.best_step = None

    def add_meta(self, metric_name, title=None, ylabel=None):
        """
        æ·»åŠ ç»˜å›¾å…ƒä¿¡æ¯
        """
        self.meta[metric_name] = {
            'title': title or metric_name,
            'ylabel': ylabel or metric_name
        }

    def record(self, step, metrics: dict):
        """
        æ·»åŠ å½“å‰è½®æ¬¡çš„å¤šä¸ªæŒ‡æ ‡
        :param step: å½“å‰è½®æ¬¡
        :param metrics: {'loss': 0.123, 'accuracy': 0.987}
        """
        for metric, value in metrics.items():
            points = self.records[metric]

            if len(points) < self.max_records:
                points.append((step, value))
            else:
                # åŠ¨æ€é‡‡æ ·
                interval = max(1, step // self.max_records)
                if step % interval == 0:
                    points.append((step, value))

    def update_best(self, step, metric_name, value, mode='min'):
        """
        æ›´æ–°æœ€ä½³ç‚¹ã€‚å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æˆ–æ¯”å·²æœ‰çš„æ›´ä¼˜ï¼Œåˆ™æ›¿æ¢ã€‚
        """
        is_better = False
        if self.best_point is None:
            is_better = True
        elif mode == 'min' and value < self.best_point['value']:
            is_better = True
        elif mode == 'max' and value > self.best_point['value']:
            is_better = True

        if is_better:
            self.best_point = {'metric': metric_name, 'step': step, 'value': value}
            self.best_step = step
            # æ’å…¥åˆ°å¯¹åº”è®°å½•ä¸­
            self._insert_best_point(metric_name, step, value)

    def _insert_best_point(self, metric_name, step, value):
        """
        ä¿è¯æœ€ä½³ç‚¹æ’å…¥æ­£ç¡®ä½ç½®ï¼Œä¸é‡å¤è®°å½•
        """
        points = self.records[metric_name]
        steps = [s for s, _ in points]
        if step in steps:
            return  # å·²å­˜åœ¨
        idx = bisect_left(steps, step)
        points.insert(idx, (step, value))

    def get_all_data(self):
        """
        è¿”å›æ‰€æœ‰è®°å½•ï¼ˆç”¨äºç»˜å›¾æˆ–å­˜å‚¨ï¼‰
        """
        return {
            'records': dict(self.records),
            'meta': self.meta,
            'best': self.best_point
        }

    def to_json(self):
        """
        è½¬æ¢ä¸º JSON å­—ç¬¦ä¸²ï¼Œä¾¿äºå­˜å…¥æ•°æ®åº“å­—æ®µ
        """
        return json.dumps(self.get_all_data(), ensure_ascii=False)
```

------

## âœ… 2. ä½¿ç”¨æ–¹å¼

```python
recorder = TrainingRecorder(max_records=1000)

recorder.add_meta('loss', title='Loss Curve', ylabel='Loss')
recorder.add_meta('accuracy', title='Accuracy Curve', ylabel='Accuracy')

for epoch in range(1, 50001):
    # å‡è®¾ä½ è®­ç»ƒè¿‡ç¨‹å¦‚ä¸‹
    train_loss = ...
    val_acc = ...
    
    recorder.record(epoch, {
        'loss': train_loss,
        'accuracy': val_acc
    })

    recorder.update_best(epoch, 'loss', train_loss, mode='min')  # è®°å½•æœ€ä¼˜æŸå¤±ç‚¹
```

------

## âœ… 3. å­˜å…¥æ•°æ®åº“ï¼ˆDjango ç¤ºä¾‹ï¼‰

```python
from django.db import models

class TrainingLog(models.Model):
    model_name = models.CharField(max_length=128)
    record_json = models.JSONField()  # å­˜æ‰€æœ‰æ•°æ®è®°å½•å’Œå…ƒä¿¡æ¯ï¼ˆåŒ…å«æœ€ä½³ç‚¹ï¼‰

# ä½¿ç”¨è®°å½•å™¨åä¿å­˜ï¼š
record_data = recorder.to_json()

TrainingLog.objects.create(
    model_name='MyModelV1',
    record_json=json.loads(record_data)
)
```

------

## âœ… æ”¯æŒçš„åŠŸèƒ½æ€»ç»“

| åŠŸèƒ½                     | è¯´æ˜                                        |
| ------------------------ | ------------------------------------------- |
| è‡ªåŠ¨é‡‡æ ·è®°å½•             | è‡ªåŠ¨æ ¹æ® `max_records` é™åˆ¶æ•°é‡             |
| å¤šæ¡æ•°æ®çº¿è®°å½•ï¼ˆå¤šæŒ‡æ ‡ï¼‰ | `record(epoch, {'loss': ..., 'acc': ...})`  |
| å›¾çº¿å…ƒä¿¡æ¯ï¼ˆæ ‡é¢˜ç­‰ï¼‰     | `add_meta(...)`                             |
| æœ€ä½³ç‚¹æ’å…¥åŸå§‹é¡ºåº       | `_insert_best_point(...)`                   |
| å•å­—æ®µ JSON å­˜å‚¨         | `to_json()`                                 |
| æœ€ä½³è½®æ¬¡ä¿¡æ¯             | `best_point` åŒ…å« `step`ã€`value`ã€`metric` |

------

å¦‚ä½ æœ‰æ›´é«˜çº§çš„éœ€æ±‚ï¼Œä¾‹å¦‚ï¼š

- ç»˜å›¾ç›´æ¥å¯¼å‡º
- å¤šä¸ªé˜¶æ®µï¼ˆå¦‚ warmupã€finetuneï¼‰åˆ†å¼€è®°å½•
- è®°å½•çš„å­—æ®µå¸¦å•ä½æˆ–æ³¨é‡Š

éƒ½å¯ä»¥åœ¨ç°æœ‰ç»“æ„ä¸Šæ‰©å±•ï¼Œæœ‰éœ€è¦æˆ‘ä¹Ÿå¯ä»¥å¸®ä½ ç»§ç»­å®Œå–„ã€‚

ä¸ºäº†å®ç°ä»¥ä¸‹ç›®æ ‡ï¼š

1. **è®°å½•è®­ç»ƒè¿‡ç¨‹ä¸­çš„æŒ‡æ ‡æ•°æ®ï¼Œé€‚é…å„ç§è®­ç»ƒè½®æ¬¡ï¼ˆ100 ~ 10,000,000ï¼‰ï¼Œå¸¦è‡ªåŠ¨é‡‡æ ·ç­–ç•¥**ï¼›
2. **è®°å½•æ¯æ¡æ•°æ®çº¿çš„ç»˜å›¾å…ƒä¿¡æ¯ï¼ˆæ ‡é¢˜ã€x/yè½´æ ‡ç­¾ç­‰ï¼‰**ï¼›
3. **è®°å½•â€œæœ€ä½³ç‚¹â€ï¼Œå¹¶å°†å…¶æ’å…¥åˆ°åˆé€‚çš„ä½ç½®**ï¼›
4. **è®°å½•â€œæœ€ä½³ç‚¹â€æ˜¯å“ªä¸€è½®æ¬¡ï¼Œå¹¶å°†æ‰€æœ‰è®°å½•ç»Ÿä¸€å­˜å…¥æ•°æ®åº“çš„ä¸€ä¸ªå­—æ®µä¸­ï¼ˆå¦‚ JSONï¼‰**ï¼›

æˆ‘ä»¬è®¾è®¡å¦‚ä¸‹æ–¹æ¡ˆï¼š

------

## âœ… ä¸€ä½“åŒ–è®­ç»ƒè®°å½•å™¨ `TrainingRecorder`

```python
import json
from typing import Any, Dict, List, Optional


class TrainingRecorder:
    def __init__(self, max_points: int = 1000):
        """
        :param max_points: æ¯æ¡çº¿æœ€å¤šè®°å½•çš„ç‚¹æ•°ï¼Œè¶…è¿‡å°†é‡‡æ ·
        """
        self.max_points = max_points
        self.lines: Dict[str, Dict[str, Any]] = {}
        self.best_point: Optional[Dict[str, Any]] = None
        self.best_epoch: Optional[int] = None

    def add_line(self, key: str, title: str, xlabel: str = "Epoch", ylabel: str = ""):
        """æ·»åŠ ä¸€æ¡æ›²çº¿è®°å½•çº¿ï¼ˆå¦‚ lossã€accuracyï¼‰"""
        self.lines[key] = {
            "title": title,
            "xlabel": xlabel,
            "ylabel": ylabel,
            "points": [],
        }

    def record(self, epoch: int, metrics: Dict[str, float]):
        """è®°å½•å½“å‰è½®æ¬¡çš„å¤šä¸ªæŒ‡æ ‡"""
        for key, value in metrics.items():
            if key not in self.lines:
                raise ValueError(f"Metric '{key}' not found. Please use add_line first.")

            line = self.lines[key]
            points = line["points"]

            # é‡‡æ ·é€»è¾‘ï¼šåªä¿ç•™ max_points ä¸ªç‚¹
            if len(points) < self.max_points:
                points.append({"x": epoch, "y": value})
            else:
                # é‡‡æ ·æ›¿æ¢é€»è¾‘ï¼ˆçº¿æ€§å‡åŒ€æ›¿æ¢ï¼‰
                idx = int(epoch / self.total_epochs * self.max_points)
                if 0 <= idx < self.max_points:
                    points[idx] = {"x": epoch, "y": value}

    def update_best(self, epoch: int, metrics: Dict[str, float]):
        """
        æ›´æ–°æœ€ä¼˜ç‚¹ï¼Œä¼šè®°å½•å®Œæ•´çš„ç‚¹ä¿¡æ¯ï¼ˆepoch + metricsï¼‰
        """
        if self.best_point is None or self._is_better(metrics):
            self.best_point = {"epoch": epoch, **metrics}
            self.best_epoch = epoch

    def _is_better(self, metrics: Dict[str, float]) -> bool:
        """å®šä¹‰æœ€ä¼˜åˆ¤æ–­é€»è¾‘ï¼ˆå¯è‡ªå®šä¹‰ï¼‰"""
        if self.best_point is None:
            return True
        # é»˜è®¤æŒ‰ 'loss' æœ€å°å€¼åˆ¤æ–­
        return metrics.get("loss", float("inf")) < self.best_point.get("loss", float("inf"))

    def finalize(self, total_epochs: int):
        """
        åœ¨è®­ç»ƒç»“æŸæ—¶è°ƒç”¨ä»¥è®¾ç½®æ€»è½®æ¬¡ä¾›é‡‡æ ·ç­–ç•¥ä½¿ç”¨
        """
        self.total_epochs = total_epochs
        # æ’å…¥ best_point åˆ°å¯¹åº”ä½ç½®
        if self.best_point and "loss" in self.lines:
            line = self.lines["loss"]
            points = line["points"]
            best_epoch = self.best_point["epoch"]
            if not any(p["x"] == best_epoch for p in points):
                points.append({"x": best_epoch, "y": self.best_point["loss"]})
                points.sort(key=lambda p: p["x"])

    def export_json(self) -> str:
        """
        å¯¼å‡ºä¸º JSON æ ¼å¼ï¼Œå¯ç›´æ¥å­˜å…¥æ•°æ®åº“å­—æ®µ
        åŒ…å«ï¼š
            - å„æ¡æ›²çº¿
            - æœ€ä½³ç‚¹ï¼ˆå¸¦å®Œæ•´ä¿¡æ¯ï¼‰
            - æœ€ä½³è½®æ¬¡
        """
        return json.dumps({
            "lines": self.lines,
            "best_epoch": self.best_epoch,
            "best_point": self.best_point
        }, ensure_ascii=False, indent=2)
```

------

## âœ… ä½¿ç”¨ç¤ºä¾‹

```python
recorder = TrainingRecorder(max_points=1000)
recorder.add_line("loss", title="è®­ç»ƒæŸå¤±", ylabel="Loss")
recorder.add_line("accuracy", title="å‡†ç¡®ç‡", ylabel="Accuracy")

total_epochs = 1000000
for epoch in range(total_epochs):
    # æ¨¡æ‹ŸæŒ‡æ ‡
    loss = 1 / (epoch + 1)
    acc = epoch / total_epochs

    recorder.record(epoch, {"loss": loss, "accuracy": acc})
    recorder.update_best(epoch, {"loss": loss, "accuracy": acc})

# æœ€ç»ˆæ•´ç†ï¼Œç¡®ä¿æ€»è½®æ¬¡ç”Ÿæ•ˆ + æ’å…¥æœ€ä½³ç‚¹
recorder.finalize(total_epochs=total_epochs)

# å¯¼å‡ºç»“æœï¼ˆå¯å­˜å…¥æ•°æ®åº“çš„å•ä¸ªå­—æ®µï¼‰
json_data = recorder.export_json()
```

------

## âœ… å­˜å…¥æ•°æ®åº“å­—æ®µï¼ˆDjangoç¤ºä¾‹ï¼‰

```python
from django.db import models

class TrainingResult(models.Model):
    model_name = models.CharField(max_length=100)
    training_record = models.JSONField()  # å­˜å‚¨ä¸Šé¢ export_json çš„ç»“æœ
```

------

## âœ… ä¼˜åŠ¿

| åŠŸèƒ½               | è¯´æ˜                               |
| ------------------ | ---------------------------------- |
| çº¿æ€§é‡‡æ ·           | è‡ªåŠ¨æ§åˆ¶è®°å½•ç‚¹æ•°ï¼Œæ”¯æŒç™¾ä¸‡è½®æ¬¡è®­ç»ƒ |
| æ’å…¥æœ€ä½³ç‚¹         | å¯ç¡®ä¿æœ€ä½³è½®æ¬¡ä»ä¿ç•™åœ¨æ›²çº¿ä¸Š       |
| å¤šæ¡æ•°æ®çº¿æ”¯æŒ     | æ¯ä¸ªæŒ‡æ ‡éƒ½æœ‰ç‹¬ç«‹é…ç½®å’Œå…ƒä¿¡æ¯       |
| æ•°æ®åº“å‹å¥½         | å…¨éƒ¨ä¿¡æ¯å°è£…ä¸ºä¸€ä¸ª JSON å­—æ®µ       |
| å¯ç›´æ¥ç”¨äºå‰ç«¯ç»˜å›¾ | è¾“å‡ºç»“æ„æ”¯æŒ x/y åæ ‡ã€æ ‡é¢˜ã€æ ‡ç­¾  |

------

å¦‚æœä½ è¿˜éœ€è¦å°†å…¶æ‹†åˆ†ä¸ºæ¨¡å—ã€æ”¯æŒæŒä¹…åŒ–ã€å¢åŠ å‰ç«¯å›¾è¡¨æ ¼å¼åŒ–æ”¯æŒï¼ˆå¦‚ chart.js / echartsï¼‰ï¼Œæˆ‘ä¹Ÿå¯ä»¥ç»§ç»­å¸®ä½ æ‰©å±•ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ

å¥½çš„ï¼Œæˆ‘ä»¬æ¥æ¢³ç†ä½ æå‡ºçš„â€œæœ€ä½³ç‚¹è®°å½•é€»è¾‘â€çš„éœ€æ±‚ï¼Œå¹¶è§£é‡Šå½“å‰å®ç°èƒŒåçš„é€»è¾‘ä»¥åŠå¯èƒ½å‡ºç°çš„â€œè¯¯åˆ¤æœ€ä½³ç‚¹â€çš„åŸå› ã€‚ä½ éœ€è¦çš„æ˜¯ï¼š

------

### âœ… **éœ€æ±‚æ€»ç»“**

1. **è®­ç»ƒè¿‡ç¨‹é‡‡æ ·è®°å½•ï¼ˆç”¨äºç»˜å›¾ï¼‰ï¼š**
   - è‡ªåŠ¨é€‚åº”ä»»æ„è½®æ¬¡æ•°é‡ï¼ˆ100 ~ 10000000ï¼‰ï¼Œæ§åˆ¶é‡‡æ ·é‡ã€‚
   - æ”¯æŒå¤šæ¡è®°å½•çº¿ï¼ˆå¦‚ lossã€val_lossã€accuracy ç­‰ï¼‰ã€‚
   - æ¯æ¡çº¿å¸¦æœ‰ `name`, `title`, `xlabel`, `ylabel` ç­‰å…ƒä¿¡æ¯ã€‚
   - æ‰€æœ‰è®°å½•éƒ½æ˜¯æœ‰åºçš„ï¼ˆæŒ‰è½®æ¬¡é€’å¢ï¼‰ã€‚
2. **è®°å½•â€œæœ€ä½³ç‚¹â€ï¼š**
   - ä»…è®°å½•ä¸€æ¬¡æœ€ä½³ç‚¹ã€‚
   - è¯¥æœ€ä½³ç‚¹æ•°æ®ä¹Ÿéœ€è¦è½å…¥å¯¹åº”çš„ä½ç½®ï¼ˆè½®æ¬¡é¡ºåºä¸­ï¼‰ã€‚
   - æœ€ä½³ç‚¹åº”åŒ…å«å’Œæ™®é€šç‚¹ç›¸åŒçš„å…¨éƒ¨ä¿¡æ¯ã€‚
   - åº”èƒ½æŒ‡å®šå“ªä¸€é¡¹æ˜¯â€œè¯„ä»·æŒ‡æ ‡â€ï¼ˆå¦‚ `val_loss` æœ€å°ã€`accuracy` æœ€å¤§ï¼‰ã€‚
   - æœ€ä½³è½®æ¬¡ä¿¡æ¯è¦å†™å…¥æ•°æ®åº“å­—æ®µï¼ˆå¦‚ `train_record_json`ï¼‰ã€‚

------

### ğŸ§  **å½“å‰æœ€ä½³ç‚¹é€»è¾‘çš„è§£é‡Š**

åœ¨ç›®å‰çš„å®ç°ä¸­ï¼Œâ€œæœ€ä½³ç‚¹â€çš„è¯†åˆ«é€»è¾‘å¯èƒ½æ˜¯è¿™æ ·çš„ï¼ˆä¼ªé€»è¾‘ï¼‰ï¼š

```python
if best_value is None or current_value < best_value:
    best_value = current_value
    best_step = current_step
    best_data = current_data  # è®°å½•è¯¥ç‚¹
```

å› æ­¤åœ¨**è®­ç»ƒæ—©æœŸ**ï¼Œä¾‹å¦‚ç¬¬ 1ã€2ã€3 æ­¥ï¼Œåªè¦ `current_value` æ¯” `best_value` å°ï¼Œå°±ä¼šè¢«è®¤ä¸ºæ˜¯â€œæœ€ä½³ç‚¹â€ï¼Œå³ä¾¿å®ƒåªæ˜¯æš‚æ—¶å¥½ä¸€ç‚¹ã€‚

------

### â—ï¸æ½œåœ¨é—®é¢˜

- **å¤šæ¬¡æ›´æ–°æœ€ä½³ç‚¹**ï¼šæ¯æ¬¡å‘ç°æ›´ä¼˜çš„æŒ‡æ ‡å°±æ›´æ–°ï¼Œå¯¼è‡´å‰æœŸé¢‘ç¹è®°å½•â€œæœ€ä½³ç‚¹â€ã€‚
- **ç»“æœâ€œæ¼‚ç§»â€æˆ–ä¸ç¨³å®š**ï¼šå¦‚æœæ—©æœŸæ•°æ®æ³¢åŠ¨å¤§ï¼Œå¯èƒ½è¯¯è®°å½•å¾ˆå¤šâ€œæ¬¡ä¼˜ç‚¹â€ã€‚

------

### âœ… **æ›´ç¨³å¥çš„â€œæœ€ä½³ç‚¹è®°å½•é€»è¾‘â€å»ºè®®**

ä½ å¯ä»¥é€‰æ‹©ï¼š

#### âœ… æ–¹æ³•ä¸€ï¼š**åªè®°å½•æœ€ç»ˆæœ€ä½³ç‚¹**

é€‚åˆè®­ç»ƒç»“æŸåè®°å½•ï¼Œä¾‹å¦‚ï¼š

```python
# åœ¨è®­ç»ƒå®Œæˆåè¿›è¡Œæ¯”è¾ƒä¸è®°å½•
final_best_step = np.argmin(val_loss_list)  # or argmax for accuracy
final_best_data = full_record[final_best_step]
```

ä¼˜ç‚¹ï¼š

- é¿å…å‰æœŸæ³¢åŠ¨å½±å“ã€‚
- ç®€æ´ã€åªå†™å…¥ä¸€æ¬¡ã€‚

------

#### âœ… æ–¹æ³•äºŒï¼š**å®æ—¶è®°å½•ä½†åªä¿å­˜ä¸€æ¬¡**

é€‚åˆå¸Œæœ›å®æ—¶è¿½è¸ªæœ€ä¼˜æ¨¡å‹çš„åŒæ—¶ï¼Œ**ä»…è®°å½•ä¸€æ¡æœ€ä½³è®°å½•æ•°æ®**ï¼š

```python
# åˆå§‹åŒ–
best_value = float('inf')
best_record = None
best_step = None

# æ¯è½®è®­ç»ƒä¸­
if metric_value < best_value:
    best_value = metric_value
    best_step = current_step
    best_record = current_metrics.copy()
```

> **æ³¨æ„**ï¼šè¿™ä¸ª `best_record` æœ€ç»ˆåªä¿å­˜ä¸€æ¬¡ï¼ŒåŠ å…¥å®Œæ•´è®°å½•åˆ—è¡¨æ—¶æ’å…¥åˆ°å¯¹åº”è½®æ¬¡é¡ºåºä¸­ã€‚

------

### âœ… å¦‚ä½•â€œæ’å…¥æœ€ä½³ç‚¹åˆ°è®°å½•åˆ—è¡¨ä¸­æ­£ç¡®ä½ç½®â€ï¼Ÿ

ä¾‹å¦‚ï¼Œè®­ç»ƒè®°å½•åˆ—è¡¨å¦‚ä¸‹ï¼š

```python
records = [
    {"step": 1, "val_loss": 0.95},
    {"step": 2, "val_loss": 0.93},
    {"step": 5, "val_loss": 0.90},
]
best = {"step": 2, "val_loss": 0.93, "is_best": True}
```

ä½ å¯ä»¥åœ¨ä¿å­˜å‰åšå¦‚ä¸‹æ’å…¥ï¼š

```python
inserted = False
for i, r in enumerate(records):
    if r["step"] > best["step"]:
        records.insert(i, best)
        inserted = True
        break

if not inserted:
    records.append(best)
```

------

### âœ… ç¤ºä¾‹è®°å½•ç»“æ„ï¼ˆæ”¯æŒå¤šæ¡çº¿ã€ç»˜å›¾ä¿¡æ¯ï¼‰

```json
{
  "title": "è®­ç»ƒè¿‡ç¨‹è®°å½•",
  "xlabel": "è½®æ¬¡",
  "ylabel": "æŒ‡æ ‡å€¼",
  "best_step": 42,
  "lines": [
    {
      "name": "loss",
      "label": "è®­ç»ƒæŸå¤±",
      "color": "#ff0000",
      "points": [[1, 0.9], [2, 0.85], ..., [42, 0.12]]
    },
    {
      "name": "val_loss",
      "label": "éªŒè¯æŸå¤±",
      "color": "#0000ff",
      "points": [[1, 1.0], [2, 0.95], ..., [42, 0.11]]
    }
  ]
}
```

ä½ å¯ä»¥å°†è¿™ä¸ª JSON å­˜å…¥æ•°æ®åº“ä¸­çš„ä¸€ä¸ª `TextField` æˆ– `JSONField` å­—æ®µï¼Œå­—æ®µåå¦‚ï¼š`train_record_json`ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ª**æ”¯æŒå¤šå›¾ï¼ˆå¤šä¸ªå­å›¾ï¼‰+ æ¯å›¾å¤šçº¿ï¼ˆå¤šæŒ‡æ ‡ï¼‰**çš„è®­ç»ƒè¿‡ç¨‹è®°å½•å™¨å®Œæ•´ç¤ºä¾‹ã€‚è¯¥è®°å½•å™¨æ”¯æŒï¼š

- è‡ªåŠ¨é‡‡æ ·ï¼ˆåŸºäºå˜åŒ–å‰§çƒˆå¯†é›†è®°å½•ã€å˜åŒ–å¹³ç¼“ç¨€ç–è®°å½•ï¼‰ï¼›
- å¤šå›¾ï¼šæ¯”å¦‚ä¸€ä¸ªå›¾å±•ç¤º Lossï¼Œå¦ä¸€ä¸ªå±•ç¤º Accuracyï¼›
- æ¯å›¾å¤šçº¿ï¼šæ¯”å¦‚ Loss å›¾ä¸­åŒ…å« train_loss å’Œ val_lossï¼›
- è®°å½•æœ€ä½³ç‚¹ï¼Œå¹¶å°†å…¶æ’å…¥åˆ°æ­£ç¡®çš„ä½ç½®ï¼›
- é™åˆ¶æœ€å¤§è®°å½•ç‚¹æ•°ï¼›
- æä¾›æ ‡é¢˜ã€x/y æ ‡ç­¾ç­‰ç»˜å›¾å…ƒä¿¡æ¯ï¼›
- å¯å°†æ‰€æœ‰è®°å½•ç»“æ„åŒ–ä¿å­˜ä¸º JSONï¼Œç”¨äºå­˜æ•°æ®åº“å­—æ®µç­‰ï¼›
- æœ€åç»˜å›¾å±•ç¤ºã€‚

------

### âœ… å®‰è£…ä¾èµ–ï¼ˆå¦‚æœæœªå®‰è£…ï¼‰

```bash
pip install matplotlib numpy
```

------

### ğŸ§  ç¤ºä¾‹ä»£ç ï¼ˆå¯ç›´æ¥è¿è¡Œï¼‰

```python
import json
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Dict, Any


class TrainingRecorder:
    def __init__(self, max_points: int = 500, delta_threshold: float = 0.01):
        """
        :param max_points: æ¯æ¡çº¿æœ€å¤šä¿ç•™å¤šå°‘ä¸ªç‚¹
        :param delta_threshold: å€¼å˜åŒ–è¶…è¿‡è¯¥æ¯”ä¾‹æ‰è®°å½•ï¼ˆç”¨äºè‡ªåŠ¨é‡‡æ ·ï¼‰
        """
        self.plots: Dict[str, Dict[str, List[Dict[str, Any]]]] = {}  # æ¯ä¸ªå›¾è¡¨åŒ…å«å¤šæ¡çº¿çš„æ•°æ®
        self.meta: Dict[str, Dict[str, str]] = {}  # æ¯ä¸ªå›¾çš„å…ƒä¿¡æ¯
        self.best_points: Dict[str, Dict[str, Dict[str, Any]]] = {}  # æ¯å›¾æ¯çº¿çš„æœ€ä½³ç‚¹è®°å½•
        self.max_points = max_points
        self.delta_threshold = delta_threshold

    def add_plot(self, plot_name: str, title: str, xlabel: str, ylabel: str):
        """æ³¨å†Œä¸€ä¸ªå›¾"""
        self.plots[plot_name] = {}
        self.meta[plot_name] = {'title': title, 'xlabel': xlabel, 'ylabel': ylabel}

    def add_series(self, plot_name: str, series_name: str):
        """æ³¨å†Œä¸€æ¡çº¿"""
        self.plots[plot_name][series_name] = []
        self.best_points.setdefault(plot_name, {})[series_name] = None

    def record(self, plot_name: str, series_name: str, x: float, y: float,
               is_best: bool = False, extra: Dict[str, Any] = None):
        """è®°å½•ä¸€æ¡æ•°æ®ç‚¹ï¼Œå¦‚æœæ³¢åŠ¨å°åˆ™å¯èƒ½è·³è¿‡"""
        series = self.plots[plot_name][series_name]
        point = {'x': x, 'y': y}
        if extra:
            point.update(extra)

        # å¦‚æœæ˜¯æœ€ä½³ç‚¹åˆ™è®°å½•å¹¶æ’å…¥æ­£ç¡®ä½ç½®
        best = self.best_points[plot_name][series_name]
        if is_best or best is None or y < best['y']:  # ä¾‹å¦‚ y è¶Šå°è¶Šå¥½
            self.best_points[plot_name][series_name] = point
            # æ’å…¥æ’åº
            series.append(point)
            series.sort(key=lambda d: d['x'])
            return

        # è‡ªåŠ¨é‡‡æ ·é€»è¾‘
        if len(series) == 0 or abs(y - series[-1]['y']) / max(abs(series[-1]['y']), 1e-8) > self.delta_threshold:
            series.append(point)

        # é™åˆ¶æœ€å¤§è®°å½•æ•°
        if len(series) > self.max_points:
            idx = np.linspace(0, len(series) - 1, self.max_points, dtype=int)
            self.plots[plot_name][series_name] = [series[i] for i in idx]

    def get_all_data(self) -> Dict[str, Any]:
        """å¯¼å‡ºæ‰€æœ‰è®°å½•æ•°æ®ï¼ŒåŒ…æ‹¬å…ƒä¿¡æ¯å’Œæœ€ä½³ç‚¹ï¼Œå¯å­˜æ•°æ®åº“"""
        return {
            'meta': self.meta,
            'data': self.plots,
            'best': self.best_points
        }

    def plot_all(self):
        """ç»˜åˆ¶æ‰€æœ‰å›¾"""
        for plot_name, series_dict in self.plots.items():
            plt.figure()
            meta = self.meta.get(plot_name, {})
            plt.title(meta.get('title', plot_name))
            plt.xlabel(meta.get('xlabel', 'X'))
            plt.ylabel(meta.get('ylabel', 'Y'))

            for series_name, points in series_dict.items():
                x_vals = [p['x'] for p in points]
                y_vals = [p['y'] for p in points]
                plt.plot(x_vals, y_vals, label=series_name)
                # æ ‡æ³¨æœ€ä½³ç‚¹
                best = self.best_points[plot_name].get(series_name)
                if best:
                    plt.scatter([best['x']], [best['y']], marker='x', color='red')
                    plt.text(best['x'], best['y'], f"Best {series_name}", fontsize=8)

            plt.legend()
            plt.grid(True)
            plt.show()


# âœ… ç¤ºä¾‹ä½¿ç”¨
recorder = TrainingRecorder(max_points=200, delta_threshold=0.01)

# æ·»åŠ ä¸¤ä¸ªå›¾ï¼Œåˆ†åˆ«æ˜¯ Loss å’Œ Accuracy
recorder.add_plot("loss_plot", "Loss Curve", "Epoch", "Loss")
recorder.add_plot("acc_plot", "Accuracy Curve", "Epoch", "Accuracy")

# æ¯ä¸ªå›¾æ·»åŠ ä¸¤æ¡çº¿ï¼šè®­ç»ƒå’ŒéªŒè¯
for plot in ["loss_plot", "acc_plot"]:
    for line in ["train", "val"]:
        recorder.add_series(plot, line)

# æ¨¡æ‹Ÿè®­ç»ƒè®°å½•è¿‡ç¨‹
for epoch in range(1, 300):
    train_loss = np.exp(-epoch / 50) + np.random.rand() * 0.02
    val_loss = np.exp(-epoch / 45) + np.random.rand() * 0.02

    train_acc = 1 - train_loss + np.random.rand() * 0.01
    val_acc = 1 - val_loss + np.random.rand() * 0.01

    recorder.record("loss_plot", "train", epoch, train_loss)
    recorder.record("loss_plot", "val", epoch, val_loss, is_best=(epoch == 150))
    recorder.record("acc_plot", "train", epoch, train_acc)
    recorder.record("acc_plot", "val", epoch, val_acc, is_best=(epoch == 150))

# å¯¼å‡ºè®°å½•æ•°æ®ï¼Œå¯ç”¨äºå­˜æ•°æ®åº“å­—æ®µï¼ˆå¦‚ JSONFieldï¼‰
record_data = recorder.get_all_data()
record_json = json.dumps(record_data)  # å­˜å‚¨åˆ°æ•°æ®åº“å­—æ®µä¸­

# æ‰“å°éƒ¨åˆ†ç»“æœ
print(f"è®°å½• JSON æ€»é•¿åº¦: {len(record_json)}")
print("æœ€ä½³ç‚¹ç¤ºä¾‹ï¼š", json.dumps(record_data['best'], indent=2))

# ç»˜å›¾
recorder.plot_all()
```

------

### ğŸ“Œ ç‰¹æ€§è¯´æ˜

| åŠŸèƒ½             | æ”¯æŒæƒ…å†µ |
| ---------------- | -------- |
| è‡ªåŠ¨é‡‡æ ·         | âœ…        |
| å¤šå›¾æ”¯æŒ         | âœ…        |
| æ¯å›¾å¤šçº¿         | âœ…        |
| æœ€ä½³ç‚¹æ’å…¥       | âœ…        |
| é™åˆ¶æœ€å¤§ç‚¹æ•°     | âœ…        |
| å…ƒä¿¡æ¯æ”¯æŒ       | âœ…        |
| JSON å¯¼å‡º        | âœ…        |
| æ”¯æŒåç»­ç»˜å›¾ä½¿ç”¨ | âœ…        |

------

å¦‚ä½ è¿˜éœ€è¦æ¥å…¥æ•°æ®åº“æ¨¡å‹ï¼ˆå¦‚ Django çš„ `JSONField`ï¼‰ï¼Œæˆ–è€…å¸Œæœ›å°†è®°å½•å™¨æ‹†åˆ†ä¸ºæ¨¡å—æ”¯æŒä¸åŒè®­ç»ƒå™¨å¤ç”¨ï¼Œä¹Ÿå¯ä»¥ç»§ç»­æ‹“å±•ã€‚æ˜¯å¦è¿˜éœ€è¦åŠ å…¥ã€Œè®­ç»ƒä¸­å®æ—¶è¾“å‡ºã€æˆ–ã€ŒWeb å‰ç«¯å®æ—¶å±•ç¤ºã€ç­‰ï¼Ÿæˆ‘ä¹Ÿå¯ä»¥ç»§ç»­æ‰©å±•ã€‚

------

å¦‚æœä½ æƒ³è¦æˆ‘å¸®ä½ å®Œå–„ä»£ç ï¼Œè‡ªåŠ¨é‡‡æ ·ã€è®°å½•ã€å¤„ç†æœ€ä½³ç‚¹å¹¶ç”Ÿæˆè¿™ç§ç»“æ„ï¼Œè¯·å‘Šè¯‰æˆ‘ä½ ç”¨çš„æ˜¯å“ªç§æ¡†æ¶ï¼ˆPyTorch / Keras / è‡ªå®šä¹‰è®­ç»ƒé€»è¾‘ï¼‰ï¼Œæˆ‘å¯ä»¥æä¾›æ•´å¥—å°è£…ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ã€å¯æ‰©å±•çš„ **å¤šå›¾å¤šçº¿è®­ç»ƒè®°å½•å™¨** ç¤ºä¾‹ï¼Œå®ƒï¼š

- æ”¯æŒ**å¤šæŒ‡æ ‡è®°å½•**ï¼ˆå¦‚ lossã€accuracyï¼‰
- æ¯ä¸ªæŒ‡æ ‡å¯é…ç½®ï¼š
  - **å›¾è¡¨ä¿¡æ¯ï¼ˆx/yè½´åã€æ ‡é¢˜ï¼‰**
  - **æ˜¯å¦è®°å½•æœ€ä½³ç‚¹**
  - **æ˜¯å¦æ³¢åŠ¨è‡ªé€‚åº”é‡‡æ ·**
- æä¾›ï¼š
  - æ³¢åŠ¨è®¡ç®—ï¼ˆæ³¢åŠ¨å‰§çƒˆå¯†é›†è®°å½•ï¼Œå¹³ç¨³æ—¶ç¨€ç–è®°å½•ï¼‰
  - æœ€ä½³ç‚¹è‡ªåŠ¨æ’å…¥åˆé€‚ä½ç½®
  - æœ€ç»ˆå¯å¯¼å‡ºæ•°æ®ï¼ˆç”¨äºå­˜æ•°æ®åº“ï¼‰

------

## âœ… ä¸€ã€æ¨¡å—ç»“æ„

æˆ‘ä»¬å°†å®ç°ä¸‰ä¸ªæ ¸å¿ƒç±»ï¼š

```python
from typing import List, Dict, Any, Optional, Callable
import matplotlib.pyplot as plt


class MetricCurve:
    """
    è¡¨ç¤ºå•æ¡å›¾çº¿ï¼šè®°å½•æŸä¸€æŒ‡æ ‡ï¼ˆå¦‚ lossã€accuracyï¼‰çš„è®­ç»ƒå€¼ã€‚
    æ”¯æŒç¨€ç–é‡‡æ ·ã€æœ€ä½³ç‚¹è‡ªåŠ¨æ’å…¥ã€ç»˜å›¾ã€‚
    """

    def __init__(
        self,
        name: str,
        title: str,
        xlabel: str = "Epoch",
        ylabel: str = "",
        track_best: bool = False,
        better_fn: Optional[Callable[[float, float], bool]] = None,
        max_points: int = 1000,
        use_adaptive_sampling: bool = True,
        window_size: int = 5,
        min_step: int = 10,
    ):
        self.name = name
        self.title = title
        self.xlabel = xlabel
        self.ylabel = ylabel or name

        self.track_best = track_best
        self.better_fn = better_fn or (lambda a, b: a < b)  # é»˜è®¤è¶Šå°è¶Šå¥½
        self.best_point = None  # (x, y)

        self.data = []  # [(x, y)]
        self.all_data = []  # å®Œæ•´è®°å½•
        self.max_points = max_points
        self.use_adaptive_sampling = use_adaptive_sampling
        self.window_size = window_size
        self.min_step = min_step

    def _compute_volatility(self) -> float:
        """è®¡ç®—æœ€è¿‘çª—å£å†…æ•°æ®çš„æ³¢åŠ¨å¹…åº¦"""
        if len(self.all_data) < self.window_size + 1:
            return float('inf')
        diffs = [
            abs(self.all_data[-i][1] - self.all_data[-i - 1][1])
            for i in range(1, self.window_size + 1)
        ]
        return sum(diffs) / len(diffs)

    def add_point(self, x: int, y: float):
        """æ·»åŠ ä¸€æ¡è®°å½•ï¼Œè‡ªåŠ¨åˆ¤æ–­æ˜¯å¦ä¿ç•™"""
        self.all_data.append((x, y))

        # æ£€æŸ¥æ˜¯å¦æ˜¯æœ€ä½³ç‚¹
        if self.track_best and (self.best_point is None or self.better_fn(y, self.best_point[1])):
            self.best_point = (x, y)

        # è‡ªé€‚åº”é‡‡æ ·é€»è¾‘
        if len(self.data) == 0:
            self.data.append((x, y))
            return

        if self.use_adaptive_sampling:
            volatility = self._compute_volatility()
            step = max(self.min_step, int(self.max_points * (1 / (volatility + 1e-6))))
            if x % step == 0:
                self.data.append((x, y))
        else:
            if len(self.data) < self.max_points:
                self.data.append((x, y))

    def finalize(self):
        """å°†æœ€ä½³ç‚¹æ’å…¥åˆé€‚ä½ç½®"""
        if self.track_best and self.best_point and self.best_point not in self.data:
            inserted = False
            for i in range(len(self.data)):
                if self.data[i][0] > self.best_point[0]:
                    self.data.insert(i, self.best_point)
                    inserted = True
                    break
            if not inserted:
                self.data.append(self.best_point)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "title": self.title,
            "xlabel": self.xlabel,
            "ylabel": self.ylabel,
            "data": self.data,
            "best_point": self.best_point,
        }

    def plot(self, ax):
        xs, ys = zip(*self.data)
        ax.plot(xs, ys, label=self.name)
        if self.track_best and self.best_point:
            ax.scatter(*self.best_point, color="red", label=f"Best {self.name}")
        ax.set_title(self.title)
        ax.set_xlabel(self.xlabel)
        ax.set_ylabel(self.ylabel)
        ax.legend()
        ax.grid(True)


class TrainingRecorder:
    """
    ç®¡ç†å¤šä¸ªæŒ‡æ ‡å›¾çº¿ï¼Œå¹¶ç»Ÿä¸€å¯¼å‡ºç»˜å›¾æˆ–æ•°æ®åº“å­˜å‚¨æ ¼å¼ã€‚
    """

    def __init__(self):
        self.curves: Dict[str, MetricCurve] = {}

    def add_curve(self, curve: MetricCurve):
        self.curves[curve.name] = curve

    def record(self, x: int, values: Dict[str, float]):
        for name, y in values.items():
            if name in self.curves:
                self.curves[name].add_point(x, y)

    def finalize(self):
        for curve in self.curves.values():
            curve.finalize()

    def export(self) -> Dict[str, Any]:
        """ç”¨äºå­˜å…¥æ•°æ®åº“çš„å•å­—æ®µè®°å½•æ ¼å¼"""
        return {
            "plots": {name: curve.to_dict() for name, curve in self.curves.items()}
        }

    def plot_all(self):
        n = len(self.curves)
        fig, axes = plt.subplots(nrows=n, ncols=1, figsize=(8, 4 * n))
        if n == 1:
            axes = [axes]
        for ax, curve in zip(axes, self.curves.values()):
            curve.plot(ax)
        plt.tight_layout()
        plt.show()
```

------

## âœ… äºŒã€ç¤ºä¾‹ç”¨æ³•ï¼ˆå¯ç›´æ¥è¿è¡Œï¼‰

```python
import random

recorder = TrainingRecorder()

# æ·»åŠ ä¸¤ä¸ªæŒ‡æ ‡çš„å›¾çº¿
recorder.add_curve(MetricCurve("loss", "è®­ç»ƒæŸå¤±", ylabel="Loss", track_best=True))
recorder.add_curve(MetricCurve("acc", "å‡†ç¡®ç‡", ylabel="Accuracy", track_best=True, better_fn=lambda a, b: a > b))

# æ¨¡æ‹Ÿè®­ç»ƒ
for epoch in range(1, 5001):
    loss = 1.0 / (epoch ** 0.5) + random.uniform(-0.02, 0.02)
    acc = 1 - loss + random.uniform(-0.01, 0.01)
    recorder.record(epoch, {"loss": loss, "acc": acc})

# æ•´ç†è®°å½•
recorder.finalize()

# å¯¼å‡ºå¹¶æ‰“å°
data_for_db = recorder.export()
print(data_for_db)

# ç»˜å›¾å±•ç¤º
recorder.plot_all()
```

------

## âœ… ä¸‰ã€ä¼˜åŠ¿æ€»ç»“

- âœ” æ”¯æŒä»»æ„å¤šå›¾ã€å¤šçº¿ã€å„è‡ªé…ç½®
- âœ” è‡ªåŠ¨åˆ¤æ–­é‡‡æ ·å¯†åº¦ï¼ˆæ³¢åŠ¨è®¡ç®—ï¼‰
- âœ” è‡ªåŠ¨è®°å½•å¹¶æ’å…¥æœ€ä½³ç‚¹
- âœ” å¯è½¬å­˜ä¸ºæ•°æ®åº“å­—æ®µï¼ˆç»“æ„æ¸…æ™°ï¼‰
- âœ” å¯è§†åŒ–å±•ç¤ºæ”¯æŒ matplotlib

------

å¦‚éœ€è¿›ä¸€æ­¥æ‰©å±•ï¼Œä¾‹å¦‚åŠ å…¥æ ‡ç­¾ã€æ‰¹æ¬¡è®°å½•ç­‰åŠŸèƒ½ï¼Œä¹Ÿå¯ä»¥ç»§ç»­åœ¨ `MetricCurve` å†…æ‰©å±•å­—æ®µï¼ˆå¦‚ `metadata`ï¼‰ï¼Œè®©æ¯æ¡çº¿æ‹¥æœ‰æ›´å¤šä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚éœ€è¦æˆ‘å¯ä»¥ç»§ç»­æ·»åŠ æ•°æ®åº“æ¨¡å‹ç¤ºä¾‹æˆ–æ”¹æˆ JSON å­˜å‚¨æ–¹å¼ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ

ä½ è¯´å¾—å¯¹ï¼Œæˆ‘ä»¬æ¥ä¸€æ­¥ä¸€æ­¥ä¿®å¤å’Œä¼˜åŒ–è¿™ä¸ªç³»ç»Ÿï¼Œä»¥æ»¡è¶³ï¼š

1. **æ”¯æŒå¤šå›¾å¤šçº¿è®°å½•**ï¼›
2. **æ”¯æŒæ³¢åŠ¨æ€§åˆ¤æ–­å®ç°å¯†é›†/ç¨€ç–è®°å½•**ï¼›
3. **å¯é…ç½®è®°å½•é™åˆ¶**ï¼›
4. **è®°å½•æœ€ä½³ç‚¹å¹¶æ’å…¥åˆé€‚ä½ç½®**ï¼›
5. **æœ€ç»ˆä»¥ JSON æ•°æ®ç»“æ„ï¼ˆå¯ç›´æ¥ä¿å­˜æ•°æ®åº“ä¸€ä¸ªå­—æ®µï¼‰**ï¼›
6. **x/y è½´ä¿¡æ¯ã€å›¾åã€æ›²çº¿åã€æ³¨é‡Šä¿¡æ¯å®Œæ•´**ï¼›
7. **å¹¶èƒ½ç›´æ¥ç»˜å›¾å±•ç¤ºéªŒè¯ã€‚**

------

## âœ… ç›®æ ‡åŠŸèƒ½è¯´æ˜

ä½ æœ€ç»ˆéœ€è¦çš„æ˜¯ï¼š

- å¤šä¸ªå›¾ï¼ˆä¾‹å¦‚ï¼štrain_lossã€val_accuracyï¼‰
- æ¯ä¸ªå›¾æœ‰å¤šæ¡çº¿ï¼ˆå¦‚ï¼šä¸åŒæ¨¡å‹æˆ–æŒ‡æ ‡ï¼‰
- æ¯æ¡çº¿è®°å½• `(step, value)`ï¼›
- æ”¯æŒ **æ³¢åŠ¨å‰§çƒˆæ—¶å¯†é›†è®°å½•**ï¼Œ**å¹³ç¨³æ—¶ç¨€ç–è®°å½•**ï¼›
- è‡ªåŠ¨è®°å½• **æœ€ä½³ç‚¹**ï¼›
- æœ€åç”Ÿæˆç»“æ„å¦‚ä¸‹ï¼š

```json
{
  "charts": {
    "train_loss": {
      "title": "Training Loss",
      "x_label": "step",
      "y_label": "loss",
      "lines": {
        "model_a": [[0, 1.0], [10, 0.85], ...],
        "model_b": ...
      },
      "best_point": {
        "model_a": {"step": 234, "value": 0.02}
      }
    },
    ...
  }
}
```

------

## âœ… ç¤ºä¾‹ä»£ç 

ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ã€å¯ç›´æ¥è¿è¡Œçš„ Python ç¤ºä¾‹ï¼ŒåŒ…å«æ¨¡æ‹Ÿè®­ç»ƒã€åŠ¨æ€è®°å½•ã€å¤šå›¾å¤šçº¿ã€æœ€ä½³ç‚¹è®°å½•ã€æ³¢åŠ¨æ§åˆ¶ã€ç»˜å›¾ã€‚

```python
import random
import matplotlib.pyplot as plt
import json
from typing import Dict, List, Tuple

class LineDataRecorder:
    def __init__(self, max_points=500, fluctuation_threshold=0.02):
        self.points: List[Tuple[int, float]] = []
        self.best_point: Tuple[int, float] = None
        self.max_points = max_points
        self.fluctuation_threshold = fluctuation_threshold

    def should_record(self, step: int, value: float) -> bool:
        """æ ¹æ®æ³¢åŠ¨æ€§å’Œæ•°é‡é™åˆ¶å†³å®šæ˜¯å¦è®°å½•"""
        if len(self.points) == 0:
            return True
        if len(self.points) >= self.max_points:
            return False

        last_step, last_value = self.points[-1]
        fluctuation = abs(value - last_value)
        return fluctuation >= self.fluctuation_threshold

    def record(self, step: int, value: float):
        if self.best_point is None or value < self.best_point[1]:
            self.best_point = (step, value)
            self.points.append((step, value))  # ç›´æ¥æ’å…¥ï¼Œåé¢æ’åº
        elif self.should_record(step, value):
            self.points.append((step, value))

        self.points = sorted(self.points, key=lambda x: x[0])

class ChartRecorder:
    def __init__(self, title: str, x_label: str, y_label: str):
        self.title = title
        self.x_label = x_label
        self.y_label = y_label
        self.lines: Dict[str, LineDataRecorder] = {}

    def record(self, line_name: str, step: int, value: float):
        if line_name not in self.lines:
            self.lines[line_name] = LineDataRecorder()
        self.lines[line_name].record(step, value)

    def to_dict(self):
        return {
            "title": self.title,
            "x_label": self.x_label,
            "y_label": self.y_label,
            "lines": {
                name: recorder.points for name, recorder in self.lines.items()
            },
            "best_point": {
                name: {"step": recorder.best_point[0], "value": recorder.best_point[1]}
                for name, recorder in self.lines.items() if recorder.best_point
            }
        }

class TrainingRecorder:
    def __init__(self):
        self.charts: Dict[str, ChartRecorder] = {}

    def record(self, chart_name: str, line_name: str, step: int, value: float,
               x_label="step", y_label="value", title=None):
        if chart_name not in self.charts:
            self.charts[chart_name] = ChartRecorder(
                title=title or chart_name,
                x_label=x_label,
                y_label=y_label
            )
        self.charts[chart_name].record(line_name, step, value)

    def to_json(self):
        return json.dumps({
            "charts": {name: chart.to_dict() for name, chart in self.charts.items()}
        }, indent=2)

    def plot(self):
        for chart_name, chart in self.charts.items():
            plt.figure(figsize=(10, 5))
            for line_name, recorder in chart.lines.items():
                steps, values = zip(*recorder.points) if recorder.points else ([], [])
                plt.plot(steps, values, label=line_name)
                # ç»˜åˆ¶æœ€ä½³ç‚¹
                if recorder.best_point:
                    step, val = recorder.best_point
                    plt.scatter(step, val, color='red')
                    plt.annotate(f"Best {val:.4f}", (step, val), textcoords="offset points", xytext=(0,10), ha='center')
            plt.title(chart.title)
            plt.xlabel(chart.x_label)
            plt.ylabel(chart.y_label)
            plt.legend()
            plt.grid(True)
            plt.show()

# ===============================
# æ¨¡æ‹Ÿè®­ç»ƒè¿‡ç¨‹
# ===============================
recorder = TrainingRecorder()

for step in range(1000):
    # æ¨¡æ‹Ÿä¸¤ä¸ªæ¨¡å‹åœ¨ä¸¤ä¸ªå›¾çš„è¡¨ç°ï¼ˆtrain_loss å’Œ val_accuracyï¼‰
    val1 = 1.0 / (1 + step * 0.01) + random.uniform(-0.01, 0.01)
    val2 = 0.5 / (1 + step * 0.005) + random.uniform(-0.02, 0.02)
    acc1 = 0.5 + 0.4 * step / 1000 + random.uniform(-0.02, 0.02)
    acc2 = 0.4 + 0.5 * step / 1000 + random.uniform(-0.03, 0.01)

    recorder.record("train_loss", "model_1", step, val1, y_label="loss", title="Training Loss")
    recorder.record("train_loss", "model_2", step, val2, y_label="loss")

    recorder.record("val_accuracy", "model_1", step, acc1, y_label="accuracy", title="Validation Accuracy")
    recorder.record("val_accuracy", "model_2", step, acc2, y_label="accuracy")

# è¾“å‡º JSONï¼ˆå¯å­˜æ•°æ®åº“ï¼‰
json_data = recorder.to_json()
print(json_data[:800] + "\n...")

# å¯è§†åŒ–
recorder.plot()
```

------

## âœ… è¯´æ˜æ€»ç»“

| åŠŸèƒ½     | å®ç°è¯´æ˜                                             |
| -------- | ---------------------------------------------------- |
| å¤šå›¾     | `charts["train_loss"]`, `charts["val_accuracy"]`     |
| å¤šçº¿     | æ¯ä¸ª chart çš„ `lines["model_1"]`, `lines["model_2"]` |
| æœ€ä½³ç‚¹   | `best_point` è‡ªåŠ¨è®°å½•å¹¶æ ‡çº¢æ˜¾ç¤º                      |
| æ³¢åŠ¨è®°å½• | `should_record()` æ§åˆ¶æ³¢åŠ¨è®°å½•                       |
| æ’å…¥æ’åº | æ‰€æœ‰è®°å½•æŒ‰ step æ’åº                                 |
| å­˜æ•°æ®åº“ | `to_json()` å¾—åˆ°ä¸€ä¸ªå®Œæ•´å­—æ®µ                         |
| é™åˆ¶ç‚¹æ•° | `max_points` é™åˆ¶æ¯æ¡æ›²çº¿çš„ç‚¹æ•°                      |
| å¯æ‰©å±•æ€§ | æ‰€æœ‰æ¨¡å—ç‹¬ç«‹å¯æ›¿æ¢                                   |

------

å¦‚æœä½ è¿˜éœ€è¦ï¼š

- è‡ªå®šä¹‰æœ€ä¼˜æŒ‡æ ‡ï¼ˆæœ€å¤§åŒ–/æœ€å°åŒ–ã€ä¸åŒæŒ‡æ ‡ï¼‰ï¼›
- æ”¯æŒä¿å­˜åˆ°æ•°æ®åº“æ¨¡å‹ï¼›
- æœ€ä½³ç‚¹æ ‡ç­¾è®°å½•å¤‡æ³¨ï¼ˆå¦‚â€œéªŒè¯æŸå¤±æœ€ä½â€ï¼‰ï¼›
- æ·»åŠ ç»˜å›¾ä¸»é¢˜é£æ ¼ï¼›

æˆ‘å¯ä»¥ç»§ç»­ä¸ºä½ æ‰©å±•ã€‚

æ˜¯å¦ç°åœ¨è¿™ç‰ˆå·²ç»ç¬¦åˆä½ å½“å‰éœ€æ±‚ï¼Ÿéœ€è¦æˆ‘å¸®ä½ æ¥å…¥ Django æ¨¡å‹æˆ–æ•°æ®åº“å­—æ®µç»“æ„å—ï¼Ÿ

å½“å‰è¿™ä¸ªç¤ºä¾‹ä¸­çš„â€œæ³¢åŠ¨è®¡ç®—â€é€»è¾‘æ ¸å¿ƒæ˜¯é€šè¿‡æ¯”è¾ƒå‰åå€¼çš„å˜åŒ–ï¼ˆä¹Ÿå°±æ˜¯æ¢¯åº¦æˆ–å·®å€¼ï¼‰æ¥å†³å®šå½“å‰è½®æ¬¡æ˜¯å¦å€¼å¾—è®°å½•ï¼š

```python
fluctuation = abs(current_value - prev_value)
if fluctuation > threshold:
    should_record = True
```

### å½“å‰æ³¢åŠ¨è®¡ç®—é€»è¾‘è¯´æ˜ï¼š

1. **è®¡ç®—çš„æ˜¯å•ç‚¹å˜åŒ–å¹…åº¦**ï¼ˆ`abs(current_value - prev_value)`ï¼‰ï¼›
2. å¦‚æœå˜åŒ–å¤§äºè®¾å®šé˜ˆå€¼ï¼ˆ`threshold`ï¼‰ï¼Œå°±è¯´æ˜å½“å‰æ•°æ®â€œæœ‰æ³¢åŠ¨â€ï¼Œäºæ˜¯è®°å½•ï¼›
3. å¦åˆ™è·³è¿‡è®°å½•ï¼›
4. åˆå§‹ç‚¹å’Œæœ€ä½³ç‚¹ä¹Ÿæ€»ä¼šè¢«è®°å½•ã€‚

------

## å­˜åœ¨çš„é—®é¢˜å’Œå¯ä¼˜åŒ–ç‚¹ï¼š

### âœ… é—®é¢˜ 1ï¼šä»…é ç›¸é‚»ç‚¹å·®å€¼ä¸å¤Ÿé²æ£’

- å•ä¸ªè·³è·ƒå¯èƒ½æ˜¯å™ªå£°ï¼Œå¯èƒ½ä¼šå¯¼è‡´â€œè¯¯åˆ¤â€ä¸ºæ³¢åŠ¨ã€‚
- æŸäº›æŒ‡æ ‡å¯èƒ½å˜åŒ–èŒƒå›´ä¸å¤§ï¼Œä½†è¶‹åŠ¿é‡è¦ï¼Œä¸èƒ½è¢«çœç•¥ã€‚

### âœ… ä¼˜åŒ–æ–¹æ¡ˆ 1ï¼šä½¿ç”¨**æ»‘åŠ¨çª—å£æ ‡å‡†å·®**æˆ–**æ»‘åŠ¨å¹³å‡å·®**

ç”¨è¿‡å»è‹¥å¹²è½®çš„æ ‡å‡†å·®æˆ–å‡å€¼å·®æ¥åˆ¤æ–­å½“å‰æ³¢åŠ¨æ›´åˆç†ï¼š

```python
import numpy as np
from collections import deque

class FluctuationTracker:
    def __init__(self, window_size=5, threshold=0.01):
        self.window = deque(maxlen=window_size)
        self.threshold = threshold

    def update(self, value):
        self.window.append(value)

    def should_record(self):
        if len(self.window) < 2:
            return True  # åˆå§‹åŒ–é˜¶æ®µè®°å½•
        std_dev = np.std(self.window)
        return std_dev > self.threshold
```

ä½¿ç”¨æ–¹å¼ï¼š

```python
tracker = FluctuationTracker(window_size=10, threshold=0.05)

for step in range(total_steps):
    value = compute_metric(step)
    tracker.update(value)
    if tracker.should_record():
        recorder.record(step, value)
```

------

### âœ… ä¼˜åŒ–æ–¹æ¡ˆ 2ï¼šè€ƒè™‘â€œæ³¢åŠ¨æ–œç‡â€å’Œâ€œæ‹Ÿåˆè¯¯å·®â€

ä½¿ç”¨ä¸€æ®µæ•°æ®çš„æ‹Ÿåˆæ›²çº¿ï¼ˆçº¿æ€§æˆ–æ ·æ¡ï¼‰æ¥è¯„ä¼°è¶‹åŠ¿æ˜¯å¦ç¨³å®šï¼Œç±»ä¼¼æŠ˜çº¿çš„å¼¯æ›²ç¨‹åº¦ã€‚è¿™ä¸ªå¯ä»¥æ›´ç²¾å‡†åœ°å®šä¹‰â€œæ˜¯å¦ç¨³å®šâ€ï¼Œä½†å¤æ‚åº¦æ›´é«˜ã€‚

------

### âœ… ä¼˜åŒ–æ–¹æ¡ˆ 3ï¼šå¢åŠ æœ€å¤§è®°å½•æ•°é™åˆ¶

åŒæ—¶åŠ å…¥æœ€å¤§è®°å½•é‡çš„é™åˆ¶ï¼Œä»¥é˜²å¤§è½®æ¬¡æ¨¡å‹ä¸‹æ•°æ®çˆ†ç‚¸ï¼š

```python
if len(recorded_data) >= max_record_limit:
    continue
```

------

### âœ… æ€»ç»“æ¨èæ³¢åŠ¨é€»è¾‘ä¼˜åŒ–ç‚¹ï¼š

| ä¼˜åŒ–é¡¹                | è¯´æ˜                         | æ˜¯å¦æ¨è       |
| --------------------- | ---------------------------- | -------------- |
| ç›¸é‚»ç‚¹å·®å€¼            | ç®€å•æœ‰æ•ˆï¼Œå®¹æ˜“å®ç°           | âœ… åˆæ­¥ä½¿ç”¨     |
| æ»‘åŠ¨çª—å£æ ‡å‡†å·®        | æ›´ç¨³å®šè¯†åˆ«æ³¢åŠ¨è¶‹åŠ¿           | âœ… æ¨è         |
| æ»‘åŠ¨å¹³å‡/çº¿æ€§å›å½’æ®‹å·® | å¯å¹³æ»‘è¶‹åŠ¿åˆ¤æ–­ï¼Œé˜²æ­¢å™ªå£°è¯¯åˆ¤ | âœ… å¦‚éœ€ç²¾ç»†æ§åˆ¶ |
| å…¨å±€æœ€å¤§ç‚¹/æœ€å°ç‚¹è®°å½• | ä¿ç•™ä»£è¡¨ç‚¹                   | âœ… æ¨è         |
| æ•°æ®ç‚¹æ•°é™åˆ¶          | é˜²æ­¢è®°å½•é‡çˆ†ç‚¸               | âœ… æ¨è         |

------

å¦‚æœä½ å¸Œæœ›ï¼Œæˆ‘å¯ä»¥æ•´ç†æˆ**å®Œæ•´çš„æ³¢åŠ¨æ„ŸçŸ¥è®°å½•ç³»ç»Ÿç¤ºä¾‹**ï¼Œæ”¯æŒï¼š

- å¤šå›¾ã€å¤šçº¿ï¼›
- æŒ‡æ ‡å…ƒä¿¡æ¯é…ç½®ï¼›
- æœ€ä½³ç‚¹è®°å½•ï¼›
- æ³¢åŠ¨æ„ŸçŸ¥ç¨€ç–é‡‡æ ·ï¼›
- æœ€å¤§è®°å½•é™åˆ¶ï¼›
- æœ€ç»ˆæ‰“åŒ…ä¸ºå­—å…¸ç»“æ„å¯ç›´æ¥å­˜å…¥æ•°æ®åº“ã€‚

æ˜¯å¦éœ€è¦æˆ‘ç°åœ¨ä¸ºä½ æ•´ç†å‡ºè¿™ä¸ªå®Œæ•´ç¤ºä¾‹ï¼Ÿ

åœ¨è¿™ä¸ªæ”¹è¿›åçš„ç‰ˆæœ¬ä¸­ï¼Œæ³¢åŠ¨è®¡ç®—ä¸è®°å½•æ§åˆ¶æ›´åŠ åˆç†ï¼Œä»¥ä¸‹æ˜¯è¯¦ç»†è¯´æ˜ï¼š

------

### âœ… å½“å‰æ³¢åŠ¨è®°å½•æœºåˆ¶è¯´æ˜ï¼š

æˆ‘ä»¬åŸºäº **ç›¸å¯¹å˜åŒ–ç‡ï¼ˆæ³¢åŠ¨ç‡ï¼‰** æ¥æ§åˆ¶æ˜¯å¦è®°å½•ä¸€ä¸ªè®­ç»ƒç‚¹ã€‚å…·ä½“é€»è¾‘å¦‚ä¸‹ï¼š

```python
volatility = abs(current - prev) / (abs(prev) + epsilon)
```

å…¶ä¸­ï¼š

- `current` æ˜¯å½“å‰å€¼ï¼›
- `prev` æ˜¯å‰ä¸€ä¸ªå·²è®°å½•çš„ç‚¹çš„å€¼ï¼›
- `epsilon` æ˜¯ä¸€ä¸ªå¾ˆå°çš„æ•°ï¼Œé˜²æ­¢é™¤é›¶ï¼›
- å½“ `volatility >= volatility_threshold` æ—¶ï¼Œåˆ¤å®šä¸ºæ³¢åŠ¨è¾ƒå¤§ï¼Œ**éœ€è¦è®°å½•å½“å‰ç‚¹**ï¼›
- å¦åˆ™ï¼Œè·³è¿‡è¿™æ¬¡è®°å½•ï¼ˆé™¤éæ˜¯æœ€ä½³ç‚¹æˆ–æŒ‡å®šé‡‡æ ·ç‚¹é—´éš”ï¼‰ã€‚

------

### âœ… ä¼˜åŒ–ç‚¹å»ºè®®ï¼š

ä½ å¯ä»¥ä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢è¿›ä¸€æ­¥æ”¹è¿›æˆ–æ‹“å±•ï¼š

#### 1. **æ³¢åŠ¨çª—å£å¹³æ»‘**

ä½¿ç”¨æ»‘åŠ¨çª—å£çš„æ ‡å‡†å·®æ¥æ›´ç¨³å®šåœ°åˆ¤æ–­æ³¢åŠ¨ï¼š

```python
import numpy as np
window = [y1, y2, ..., yn]  # æœ€æ–°çš„ n ä¸ª y å€¼
volatility = np.std(window) / (np.mean(window) + epsilon)
```

é€‚ç”¨äºæ³¢åŠ¨éå•ç‚¹çªå˜çš„åœºæ™¯ï¼Œèƒ½æ›´å‡†ç¡®åœ°åæ˜ æ•´ä½“è¶‹åŠ¿ã€‚

------

#### 2. **è‡ªé€‚åº”é˜ˆå€¼**

åŠ¨æ€è°ƒæ•´æ³¢åŠ¨é˜ˆå€¼ï¼Œæ¯”å¦‚éšç€ epoch å¢é•¿é€æ¸è°ƒé«˜ï¼š

```python
volatility_threshold = base_threshold * (1 + epoch / max_epoch)
```

åˆæœŸè®°å½•å¯†é›†ï¼ŒåæœŸæ¸ç–ï¼Œé€‚åˆæ¨¡å‹è®­ç»ƒåˆæœŸå˜åŒ–å‰§çƒˆã€åæœŸè¶‹ç¨³çš„è§„å¾‹ã€‚

------

#### 3. **æœ€å°é‡‡æ ·é—´éš”æ§åˆ¶**

é¿å…é¢‘ç¹è®°å½•å¸¦æ¥æ€§èƒ½å¼€é”€ï¼š

```python
if step - last_recorded_step < min_interval:
    continue
```

------

#### 4. **å¤šå›¾å¤šçº¿æŒ‡æ ‡ç®¡ç†**

å½“å‰ä»£ç æ”¯æŒåŒæ—¶è®°å½•å¤šä¸ªå›¾ï¼ˆå›¾åï¼‰ä¸å¤šæ¡çº¿ï¼ˆy åç§°ï¼‰ã€‚ä½ å¯ä»¥ä¸ºæ¯å¼ å›¾åˆ†åˆ«è®¾ç½®ï¼š

- x è½´å­—æ®µï¼ˆå¦‚ epochã€stepï¼‰ï¼›
- y è½´å¤šä¸ªå­—æ®µï¼ˆlossã€accuracy ç­‰ï¼‰ï¼›
- å›¾çš„å…ƒä¿¡æ¯ï¼ˆtitleã€é¢œè‰²ã€å•ä½ï¼‰ç­‰ã€‚

------

#### 5. **æ•°æ®åº“è®°å½•æ•´åˆ**

å¦‚æœéœ€è¦å°†æ‰€æœ‰è®°å½•æ•°æ®ç»Ÿä¸€åºåˆ—åŒ–å­˜å…¥æ•°æ®åº“çš„ä¸€ä¸ªå­—æ®µï¼Œå»ºè®®æ ¼å¼ï¼š

```json
{
  "best_step": 129,
  "records": {
    "loss_plot": {
      "meta": {"title": "Loss Curve", "xlabel": "Epoch", "ylabel": "Loss"},
      "data": {
        "train": [[x1, y1], [x2, y2], ...],
        "val": [[x1, y1], [x2, y2], ...]
      }
    },
    "acc_plot": {
      "meta": {"title": "Accuracy Curve", "xlabel": "Epoch", "ylabel": "Accuracy"},
      "data": {
        "train": [[x1, y1], ...],
        "val": [[x1, y1], ...]
      }
    }
  }
}
```

å¯ä½¿ç”¨ `json.dumps(record_object)` å­˜å…¥ JSONField ç±»å‹å­—æ®µã€‚

------

æ˜¯å¦å¸Œæœ›æˆ‘ä¸ºä½ åŠ å…¥â€œæ»‘åŠ¨çª—å£æ³¢åŠ¨è®¡ç®—â€å’Œâ€œè‡ªé€‚åº”é‡‡æ ·æ§åˆ¶â€çš„å®Œæ•´ç‰ˆæœ¬ä»£ç ï¼Ÿ
