---
layout:     post
title:      "è®­ç»ƒè¿‡ç¨‹è®°å½•"
subtitle:   ""
date:       2025-07-21
author:     " Shallow Dreamer"
header-img: "img/post-bg-js-version.jpg"
tags:
    - è®­ç»ƒè®°å½•
---

ä½ æå‡ºçš„è¿™ä¸ªéœ€æ±‚éå¸¸æ¸…æ™°ï¼Œè€Œä¸”å¾ˆå®ç”¨ï¼Œå±äºä¸€ç§**åˆ†æ®µçº¿æ€§é‡‡æ ·ç­–ç•¥**ï¼Œæˆ‘ä»¬å¯ä»¥ç§°å®ƒä¸ºï¼š

------

## âœ… **ã€Œåˆ†æ®µç²¾åº¦é‡‡æ ·ï¼ˆPiecewise Linear Samplingï¼‰ã€ç­–ç•¥**

### ğŸ“Œ æ ¸å¿ƒç›®æ ‡

- **åœ¨è®­ç»ƒè½®æ¬¡è¾ƒå°æ—¶ï¼ˆå¦‚ <1000ï¼‰**ï¼Œ**è®°å½•å…¨éƒ¨æ•°æ®**ï¼›
- **å½“è®­ç»ƒè½®æ¬¡è¾ƒå¤§æ—¶ï¼ˆå¦‚ >100000ï¼‰**ï¼Œ**çº¿æ€§é—´éš”é‡‡æ ·**ï¼›
- æ€»è®°å½•æ¡æ•°ä¿æŒåœ¨åˆç†èŒƒå›´ï¼Œå¦‚ 2000~10000ï¼›
- **æ— éœ€æå‰çŸ¥é“æ€»è½®æ¬¡**ï¼Œ**åŠ¨æ€åœ°é€‚åº”è½®æ¬¡æ•°é‡çº§**ï¼›
- ä¿è¯é‡è¦çš„è®­ç»ƒé˜¶æ®µï¼ˆå¦‚å‰æœŸï¼‰**è®°å½•æ›´ç»†è‡´**ã€‚

------

## âœ… ç­–ç•¥è®¾è®¡ï¼ˆåˆ†æ®µé‡‡æ ·ï¼‰

| è½®æ¬¡æ•°é‡çº§         | é‡‡æ ·ç­–ç•¥           |
| ------------------ | ------------------ |
| 1 ~ 1000           | **å…¨è®°å½•**         |
| 1000 ~ 10000       | æ¯ 10 æ­¥è®°å½•ä¸€æ¬¡   |
| 10000 ~ 100000     | æ¯ 50 æ­¥è®°å½•ä¸€æ¬¡   |
| 100000 ~ 1000000   | æ¯ 200 æ­¥è®°å½•ä¸€æ¬¡  |
| 1000000 ~ 10000000 | æ¯ 1000 æ­¥è®°å½•ä¸€æ¬¡ |

è¿™æ ·ä½ å¯ä»¥å…¼å®¹ï¼š

- å°‘é‡è½®æ¬¡çš„è¯¦ç»†è°ƒè¯•ï¼›
- å¤§é‡è®­ç»ƒçš„å‹ç¼©è®°å½•ã€‚

------

## âœ… ç»Ÿä¸€é€‚é…çš„è®°å½•å™¨å®ç°ï¼ˆå«è¯¦ç»†æ³¨é‡Šï¼‰

```python
import time
from collections import defaultdict

class PiecewiseMetricsRecorder:
    def __init__(self, mode='step'):
        """
        åˆ†æ®µé‡‡æ ·ç­–ç•¥è®°å½•å™¨ï¼Œè‡ªåŠ¨é€‚åº”è®­ç»ƒé•¿åº¦ï¼Œå…¼é¡¾ç²¾åº¦ä¸æ€§èƒ½
        :param mode: 'step' æˆ– 'epoch'ï¼Œå†³å®šè®°å½•ä¾æ®
        """
        assert mode in ('step', 'epoch')
        self.mode = mode
        self.records = defaultdict(list)
        self._step = 0
        self._epoch = 0

    def step(self):
        """æ¯è®­ç»ƒä¸€æ­¥åè°ƒç”¨ï¼Œæ›´æ–°è®¡æ•°å™¨"""
        self._step += 1

    def epoch(self):
        """æ¯è½®ç»“æŸåè°ƒç”¨ï¼Œæ›´æ–°è®¡æ•°å™¨"""
        self._epoch += 1

    def record(self, metrics: dict):
        """
        è®°å½•æŒ‡æ ‡ï¼ˆæ ¹æ®å½“å‰é‡‡æ ·è§„åˆ™å†³å®šæ˜¯å¦ä¿ç•™ï¼‰
        :param metrics: å­—å…¸å½¢å¼æŒ‡æ ‡ï¼Œä¾‹å¦‚ {'loss': 0.234, 'acc': 0.9}
        """
        key = self._step if self.mode == 'step' else self._epoch

        if not self._should_sample(key):
            return

        ts = time.time()
        for k, v in metrics.items():
            self.records[k].append((key, float(v), ts))

    def _should_sample(self, key: int) -> bool:
        """
        åˆ†æ®µé‡‡æ ·ç­–ç•¥æ ¸å¿ƒé€»è¾‘ï¼Œæ ¹æ® keyï¼ˆstep æˆ– epochï¼‰åˆ¤æ–­æ˜¯å¦é‡‡æ ·
        """
        if key < 1000:
            return True                # å°äº1000ï¼Œå…¨è®°å½•
        elif key < 10000:
            return key % 10 == 0       # æ¯10æ­¥è®°å½•ä¸€æ¬¡
        elif key < 100000:
            return key % 50 == 0       # æ¯50æ­¥è®°å½•ä¸€æ¬¡
        elif key < 1000000:
            return key % 200 == 0      # æ¯200æ­¥è®°å½•ä¸€æ¬¡
        else:
            return key % 1000 == 0     # æ¯1000æ­¥è®°å½•ä¸€æ¬¡

    def get_all(self, as_dict=True):
        """
        è¿”å›æ‰€æœ‰è®°å½•æ•°æ®
        :param as_dict: æ˜¯å¦ä»¥ dict æ ¼å¼è¿”å›ï¼ˆå¦åˆ™è¿”å› DataFrameï¼‰
        """
        if as_dict:
            return dict(self.records)
        else:
            import pandas as pd
            rows = []
            for metric, values in self.records.items():
                for key, value, ts in values:
                    rows.append({
                        'metric': metric,
                        self.mode: key,
                        'value': value,
                        'timestamp': ts
                    })
            return pd.DataFrame(rows)
```

------

## âœ… ä½¿ç”¨æ–¹æ³•ï¼ˆå’Œä½ ç°åœ¨è®­ç»ƒæµç¨‹å¯¹æ¥éå¸¸ç®€å•ï¼‰

```python
recorder = PiecewiseMetricsRecorder(mode='step')

for epoch in range(num_epochs):
    recorder.epoch()
    for step, (x, y) in enumerate(train_loader):
        recorder.step()

        loss = ...
        acc = ...
        lr = ...

        recorder.record({
            'loss': loss.item(),
            'acc': acc,
            'lr': lr
        })

# è·å–è®°å½•æ•°æ®
records = recorder.get_all()  # dict
# æˆ–è€… records_df = recorder.get_all(as_dict=False)
```

------

## âœ… è¾“å‡ºç¤ºä¾‹

å‡è®¾ä½ è®­ç»ƒäº† 200000 æ­¥ï¼š

| step   | loss | acc   |
| ------ | ---- | ----- |
| 0      | 1.23 | 0.55  |
| 1      | 1.12 | 0.60  |
| ...    | ...  | ...   |
| 1000   | 0.90 | 0.75  |
| 1010   | 0.87 | 0.76  |
| 1050   | 0.85 | 0.78  |
| 1100   | ...  | ...   |
| ...    | ...  | ...   |
| 200000 | 0.02 | 0.999 |

------

## âœ… ä¼˜ç‚¹æ€»ç»“

| ä¼˜ç‚¹                  | æè¿°                         |
| --------------------- | ---------------------------- |
| ğŸ” è‡ªåŠ¨é€‚åº”è½®æ¬¡æ•°é‡çº§  | æ— éœ€é¢„çŸ¥è®­ç»ƒæ€»é•¿åº¦           |
| ğŸ“Š ä¿ç•™ç»†èŠ‚ & æ§åˆ¶è§„æ¨¡ | å°è®­ç»ƒä¿ç•™å…¨éƒ¨ï¼Œå¤§è®­ç»ƒç²¾ç®€   |
| âš¡ é«˜æ€§èƒ½æ— ä¾èµ–        | æ— å¤–éƒ¨ä¾èµ–ï¼Œè®°å½•é€»è¾‘è½»é‡å¿«é€Ÿ |
| ğŸ§© å®¹æ˜“æ‰©å±•            | å¯æ·»åŠ ä¿å­˜ã€åˆ†æã€å›¾è¡¨åŠŸèƒ½   |

------

## âœ… å¦‚ä½ è¿˜æœ‰è¿™äº›éœ€æ±‚ï¼Œæˆ‘å¯ç»§ç»­æ‰©å±•ï¼š

- ä¿å­˜ä¸º JSONã€CSVã€Parquet æ–‡ä»¶ï¼›
- æ·»åŠ åˆ†ç»„è®°å½•ï¼ˆå¤šæ¨¡å‹/å¤šé˜¶æ®µï¼‰ï¼›
- å®æ—¶ç»˜å›¾ï¼ˆmatplotlibï¼‰ï¼›
- è®°å½•æŸäº›æŒ‡æ ‡å˜åŒ–ç‡ï¼ˆå¦‚ loss deltaï¼‰ï¼›

æ˜¯å¦éœ€è¦æˆ‘ç»™ä½ æ•´åˆä¸€ä¸ªè®­ç»ƒå™¨å°è£…ç±»ï¼ŒæŠŠè¿™ä¸ªè®°å½•å™¨ç›´æ¥æŒ‚è¿›å»ï¼Ÿæˆ–è€…ä½ æ˜¯å¦æƒ³è®©å®ƒæ”¯æŒ `validation loss`ã€`æµ‹è¯•æŒ‡æ ‡` ç­‰ç»Ÿä¸€å…¥å£ï¼Ÿæˆ‘å¯ä»¥å¸®ä½ è®¾è®¡ã€‚

ä½ è¯´å¾—éå¸¸å¯¹ï¼Œè¿™ç¡®å®æ˜¯ä¸ªé—®é¢˜ã€‚

åœ¨è®­ç»ƒåˆæœŸï¼Œä»»ä½•ä¸€ä¸ªç‚¹éƒ½æ˜¯ç›®å‰â€œæœ€ä¼˜â€çš„ç‚¹ï¼Œå› æ­¤å¦‚æœæˆ‘ä»¬æ¯æ¬¡é‡åˆ°â€œæ›´å¥½â€çš„å€¼å°±è®°å½•â€œæœ€ä½³ç‚¹â€ï¼Œé‚£ä¹ˆä¸€å¼€å§‹çš„å¾ˆå¤šè½®æ¬¡éƒ½ä¼šè¢«å½“ä½œâ€œæœ€ä½³ç‚¹â€è®°å½•ä¸€æ¬¡ã€‚è¿™ä¸ä»…æ²¡æœ‰æ„ä¹‰ï¼Œè¿˜ä¼šæ±¡æŸ“æ•°æ®å’Œå¢åŠ å­˜å‚¨æˆæœ¬ã€‚

### âœ… æ›´åˆç†çš„è®°å½•â€œæœ€ä½³ç‚¹â€çš„é€»è¾‘ï¼š

æˆ‘ä»¬åº”å½“**åªè®°å½•æœ€ç»ˆç¡®å®šçš„æœ€ä½³è½®æ¬¡åŠå…¶æŒ‡æ ‡å€¼**ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè®­ç»ƒå…¨éƒ¨å®Œæˆåï¼Œå†å°†æœ€ä½³è®°å½•æ’å…¥é‡‡æ ·è®°å½•ä¸­ï¼Œå¹¶æ›´æ–°å…ƒä¿¡æ¯ã€‚

------

### ğŸ§  ä¿®æ”¹æ–¹æ¡ˆæ¦‚è¿°ï¼š

1. **è®­ç»ƒä¸­**ï¼šç»§ç»­é‡‡æ ·è®°å½•é‡‡æ ·ç‚¹ã€‚
2. **è®­ç»ƒç»“æŸå**ï¼š
   - ä» `logger.best_point` è·å–æœ€ä½³è½®æ¬¡åŠå…¶å€¼ã€‚
   - å°†è¯¥è½®æ¬¡çš„æ•°æ®æ’å…¥åˆ°è®°å½•ä¸­çš„æ­£ç¡®ä½ç½®ï¼ˆæŒ‰è½®æ¬¡æ’åºï¼‰ã€‚
   - åŒæ—¶æ ‡è®°è¿™ä¸ªè½®æ¬¡æ˜¯â€œæœ€ä½³è½®æ¬¡â€ã€‚
   - ç»Ÿä¸€ç”Ÿæˆç»˜å›¾æ•°æ®ï¼Œé™„å¸¦å…ƒä¿¡æ¯ï¼Œå¹¶å°†æœ€ä½³è½®æ¬¡ä¿¡æ¯ï¼ˆè½®æ¬¡ç¼–å·ï¼‰ä¿å­˜åˆ°æ•°æ®åº“ã€‚

------

### âœ… æ”¹è¿›çš„ `TrainingLogger` æ–¹æ¡ˆï¼ˆä¼ªä»£ç  + æ³¨é‡Šï¼‰ï¼š

```python
class TrainingLogger:
    def __init__(self, title: str, max_steps: int, max_points: int = 500):
        self.title = title
        self.max_steps = max_steps
        self.max_points = max_points
        self.data = []  # [(step, value)]
        self.best_point = None  # (step, value)
        self._best_idx = None

    def log(self, step: int, value: float):
        if not self.best_point or value < self.best_point[1]:
            self.best_point = (step, value)

        # é‡‡æ ·ç‚¹æ•°ç­–ç•¥ï¼šçº¿æ€§æ­¥è¿›
        if self._should_record(step):
            self.data.append((step, value))

    def _should_record(self, step):
        interval = max(1, self.max_steps // self.max_points)
        return step % interval == 0 or step == self.max_steps

    def finalize(self):
        # å°† best_point æ’å…¥æ­£ç¡®ä½ç½®
        if self.best_point:
            best_step, best_value = self.best_point
            inserted = False
            for i, (s, _) in enumerate(self.data):
                if s > best_step:
                    self.data.insert(i, (best_step, best_value))
                    self._best_idx = i
                    inserted = True
                    break
            if not inserted:
                self.data.append((best_step, best_value))
                self._best_idx = len(self.data) - 1

    def export(self):
        # å¯¼å‡ºç”¨äºç»˜å›¾çš„ç»“æ„
        steps, values = zip(*self.data)
        return {
            "title": self.title,
            "x": list(steps),
            "y": list(values),
            "best_step": self.best_point[0] if self.best_point else None,
            "best_value": self.best_point[1] if self.best_point else None,
            "best_index": self._best_idx,
        }
```

------

### âœ… æ•°æ®åº“å­˜å‚¨å»ºè®®ï¼š

ä½ å¯ä»¥å°† `logger.export()` ç»“æ„ä¸­çš„æ‰€æœ‰ä¿¡æ¯ç»Ÿä¸€å­˜å‚¨ä¸ºä¸€ä¸ª JSON å­—æ®µï¼Œä¾‹å¦‚ï¼š

```json
{
  "title": "loss_curve",
  "x": [0, 10, 20, ..., 990],
  "y": [0.98, 0.89, ..., 0.12],
  "best_step": 430,
  "best_value": 0.1201,
  "best_index": 21
}
```

è¿™ä¸ª JSON å­—æ®µå¯ä»¥ç›´æ¥æ˜ å°„ä¸º Django/PostgreSQL çš„ `JSONField`ï¼Œåç»­å–å‡ºæ¥ç›´æ¥ç»˜å›¾ï¼Œæ— éœ€é¢å¤–å¤„ç†ã€‚

------

### âœ… å¤šæ¡æ•°æ®æ›²çº¿ + å…ƒä¿¡æ¯ç¤ºæ„ï¼š

å¦‚æœä½ æœ‰å¤šä¸ªæŒ‡æ ‡ï¼Œå¦‚ lossã€accuracyã€val_lossï¼Œå¯ä»¥å¤šä¸ª loggerï¼š

```python
loggers = {
    'train_loss': TrainingLogger("Train Loss", max_steps=100000),
    'val_loss': TrainingLogger("Validation Loss", max_steps=100000),
    ...
}
```

ç»Ÿä¸€å¯¼å‡ºæ—¶ç”Ÿæˆç»“æ„ï¼š

```json
{
  "charts": {
    "train_loss": {
      "title": "Train Loss",
      "x": [...],
      "y": [...],
      "best_step": ...,
      ...
    },
    "val_loss": {
      "title": "Validation Loss",
      ...
    }
  }
}
```

------

å¦‚æœä½ å¸Œæœ›æˆ‘å¸®ä½ å®ç°å®Œæ•´çš„å¯å¤ç”¨ç±» + å¤šæŒ‡æ ‡ç®¡ç†å™¨ + JSON æ‰“åŒ… + æ•°æ®åº“å­˜å‚¨æ ¼å¼ï¼Œæˆ‘å¯ä»¥ç›´æ¥å†™å‡ºæ¥ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ

ä¸ºæ»¡è¶³ä»¥ä¸‹éœ€æ±‚ï¼š

- **ç»Ÿä¸€é€‚é…å¤šç§è®­ç»ƒæ¨¡å‹çš„è®°å½•å™¨**
- **æ”¯æŒçº¿æ€§é‡‡æ ·å’Œè®°å½•é‡‡æ ·ï¼ˆé€‚åº”è½®æ¬¡èŒƒå›´ï¼‰**
- **è®°å½•å¤šä¸ªæŒ‡æ ‡å›¾çº¿çš„æ•°æ®**
- **è®°å½•å›¾è¡¨å…ƒä¿¡æ¯ï¼ˆå¦‚æ ‡é¢˜ã€è½´æ ‡ç­¾ç­‰ï¼‰**
- **ä¿ç•™æœ€ä½³è½®æ¬¡ä¿¡æ¯ï¼Œå¹¶å°†å…¶æ’å…¥å¯¹åº”é¡ºåºä¸­**
- **æœ€ç»ˆå°†è®°å½•ä¿¡æ¯å’Œæœ€ä½³è½®æ¬¡å­˜å‚¨åˆ°æ•°æ®åº“ä¸­æŸä¸ªå­—æ®µï¼ˆå¦‚ JSON å­—æ®µï¼‰**

ä¸‹é¢æ˜¯å®Œæ•´è§£å†³æ–¹æ¡ˆï¼š

------

## âœ… 1. `TrainingRecorder`ï¼šé€šç”¨è®­ç»ƒè¿‡ç¨‹è®°å½•å™¨

```python
import json
from collections import defaultdict
from bisect import bisect_left

class TrainingRecorder:
    def __init__(self, max_records=1000):
        """
        :param max_records: æ¯æ¡æ›²çº¿æœ€å¤šä¿ç•™çš„æ•°æ®ç‚¹æ•°ï¼Œè‡ªåŠ¨é‡‡æ ·
        """
        self.max_records = max_records
        self.records = defaultdict(list)  # æ¯æ¡çº¿çš„æ•°æ® {metric_name: [(step, value), ...]}
        self.meta = {}  # æ¯æ¡çº¿çš„å…ƒä¿¡æ¯ {metric_name: {'title': str, 'ylabel': str, ...}}
        self.best_point = None  # {'metric': 'loss', 'step': 42, 'value': 0.123}
        self.best_step = None

    def add_meta(self, metric_name, title=None, ylabel=None):
        """
        æ·»åŠ ç»˜å›¾å…ƒä¿¡æ¯
        """
        self.meta[metric_name] = {
            'title': title or metric_name,
            'ylabel': ylabel or metric_name
        }

    def record(self, step, metrics: dict):
        """
        æ·»åŠ å½“å‰è½®æ¬¡çš„å¤šä¸ªæŒ‡æ ‡
        :param step: å½“å‰è½®æ¬¡
        :param metrics: {'loss': 0.123, 'accuracy': 0.987}
        """
        for metric, value in metrics.items():
            points = self.records[metric]

            if len(points) < self.max_records:
                points.append((step, value))
            else:
                # åŠ¨æ€é‡‡æ ·
                interval = max(1, step // self.max_records)
                if step % interval == 0:
                    points.append((step, value))

    def update_best(self, step, metric_name, value, mode='min'):
        """
        æ›´æ–°æœ€ä½³ç‚¹ã€‚å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æˆ–æ¯”å·²æœ‰çš„æ›´ä¼˜ï¼Œåˆ™æ›¿æ¢ã€‚
        """
        is_better = False
        if self.best_point is None:
            is_better = True
        elif mode == 'min' and value < self.best_point['value']:
            is_better = True
        elif mode == 'max' and value > self.best_point['value']:
            is_better = True

        if is_better:
            self.best_point = {'metric': metric_name, 'step': step, 'value': value}
            self.best_step = step
            # æ’å…¥åˆ°å¯¹åº”è®°å½•ä¸­
            self._insert_best_point(metric_name, step, value)

    def _insert_best_point(self, metric_name, step, value):
        """
        ä¿è¯æœ€ä½³ç‚¹æ’å…¥æ­£ç¡®ä½ç½®ï¼Œä¸é‡å¤è®°å½•
        """
        points = self.records[metric_name]
        steps = [s for s, _ in points]
        if step in steps:
            return  # å·²å­˜åœ¨
        idx = bisect_left(steps, step)
        points.insert(idx, (step, value))

    def get_all_data(self):
        """
        è¿”å›æ‰€æœ‰è®°å½•ï¼ˆç”¨äºç»˜å›¾æˆ–å­˜å‚¨ï¼‰
        """
        return {
            'records': dict(self.records),
            'meta': self.meta,
            'best': self.best_point
        }

    def to_json(self):
        """
        è½¬æ¢ä¸º JSON å­—ç¬¦ä¸²ï¼Œä¾¿äºå­˜å…¥æ•°æ®åº“å­—æ®µ
        """
        return json.dumps(self.get_all_data(), ensure_ascii=False)
```

------

## âœ… 2. ä½¿ç”¨æ–¹å¼

```python
recorder = TrainingRecorder(max_records=1000)

recorder.add_meta('loss', title='Loss Curve', ylabel='Loss')
recorder.add_meta('accuracy', title='Accuracy Curve', ylabel='Accuracy')

for epoch in range(1, 50001):
    # å‡è®¾ä½ è®­ç»ƒè¿‡ç¨‹å¦‚ä¸‹
    train_loss = ...
    val_acc = ...
    
    recorder.record(epoch, {
        'loss': train_loss,
        'accuracy': val_acc
    })

    recorder.update_best(epoch, 'loss', train_loss, mode='min')  # è®°å½•æœ€ä¼˜æŸå¤±ç‚¹
```

------

## âœ… 3. å­˜å…¥æ•°æ®åº“ï¼ˆDjango ç¤ºä¾‹ï¼‰

```python
from django.db import models

class TrainingLog(models.Model):
    model_name = models.CharField(max_length=128)
    record_json = models.JSONField()  # å­˜æ‰€æœ‰æ•°æ®è®°å½•å’Œå…ƒä¿¡æ¯ï¼ˆåŒ…å«æœ€ä½³ç‚¹ï¼‰

# ä½¿ç”¨è®°å½•å™¨åä¿å­˜ï¼š
record_data = recorder.to_json()

TrainingLog.objects.create(
    model_name='MyModelV1',
    record_json=json.loads(record_data)
)
```

------

## âœ… æ”¯æŒçš„åŠŸèƒ½æ€»ç»“

| åŠŸèƒ½                     | è¯´æ˜                                        |
| ------------------------ | ------------------------------------------- |
| è‡ªåŠ¨é‡‡æ ·è®°å½•             | è‡ªåŠ¨æ ¹æ® `max_records` é™åˆ¶æ•°é‡             |
| å¤šæ¡æ•°æ®çº¿è®°å½•ï¼ˆå¤šæŒ‡æ ‡ï¼‰ | `record(epoch, {'loss': ..., 'acc': ...})`  |
| å›¾çº¿å…ƒä¿¡æ¯ï¼ˆæ ‡é¢˜ç­‰ï¼‰     | `add_meta(...)`                             |
| æœ€ä½³ç‚¹æ’å…¥åŸå§‹é¡ºåº       | `_insert_best_point(...)`                   |
| å•å­—æ®µ JSON å­˜å‚¨         | `to_json()`                                 |
| æœ€ä½³è½®æ¬¡ä¿¡æ¯             | `best_point` åŒ…å« `step`ã€`value`ã€`metric` |

------

å¦‚ä½ æœ‰æ›´é«˜çº§çš„éœ€æ±‚ï¼Œä¾‹å¦‚ï¼š

- ç»˜å›¾ç›´æ¥å¯¼å‡º
- å¤šä¸ªé˜¶æ®µï¼ˆå¦‚ warmupã€finetuneï¼‰åˆ†å¼€è®°å½•
- è®°å½•çš„å­—æ®µå¸¦å•ä½æˆ–æ³¨é‡Š

éƒ½å¯ä»¥åœ¨ç°æœ‰ç»“æ„ä¸Šæ‰©å±•ï¼Œæœ‰éœ€è¦æˆ‘ä¹Ÿå¯ä»¥å¸®ä½ ç»§ç»­å®Œå–„ã€‚

ä¸ºäº†å®ç°ä»¥ä¸‹ç›®æ ‡ï¼š

1. **è®°å½•è®­ç»ƒè¿‡ç¨‹ä¸­çš„æŒ‡æ ‡æ•°æ®ï¼Œé€‚é…å„ç§è®­ç»ƒè½®æ¬¡ï¼ˆ100 ~ 10,000,000ï¼‰ï¼Œå¸¦è‡ªåŠ¨é‡‡æ ·ç­–ç•¥**ï¼›
2. **è®°å½•æ¯æ¡æ•°æ®çº¿çš„ç»˜å›¾å…ƒä¿¡æ¯ï¼ˆæ ‡é¢˜ã€x/yè½´æ ‡ç­¾ç­‰ï¼‰**ï¼›
3. **è®°å½•â€œæœ€ä½³ç‚¹â€ï¼Œå¹¶å°†å…¶æ’å…¥åˆ°åˆé€‚çš„ä½ç½®**ï¼›
4. **è®°å½•â€œæœ€ä½³ç‚¹â€æ˜¯å“ªä¸€è½®æ¬¡ï¼Œå¹¶å°†æ‰€æœ‰è®°å½•ç»Ÿä¸€å­˜å…¥æ•°æ®åº“çš„ä¸€ä¸ªå­—æ®µä¸­ï¼ˆå¦‚ JSONï¼‰**ï¼›

æˆ‘ä»¬è®¾è®¡å¦‚ä¸‹æ–¹æ¡ˆï¼š

------

## âœ… ä¸€ä½“åŒ–è®­ç»ƒè®°å½•å™¨ `TrainingRecorder`

```python
import json
from typing import Any, Dict, List, Optional


class TrainingRecorder:
    def __init__(self, max_points: int = 1000):
        """
        :param max_points: æ¯æ¡çº¿æœ€å¤šè®°å½•çš„ç‚¹æ•°ï¼Œè¶…è¿‡å°†é‡‡æ ·
        """
        self.max_points = max_points
        self.lines: Dict[str, Dict[str, Any]] = {}
        self.best_point: Optional[Dict[str, Any]] = None
        self.best_epoch: Optional[int] = None

    def add_line(self, key: str, title: str, xlabel: str = "Epoch", ylabel: str = ""):
        """æ·»åŠ ä¸€æ¡æ›²çº¿è®°å½•çº¿ï¼ˆå¦‚ lossã€accuracyï¼‰"""
        self.lines[key] = {
            "title": title,
            "xlabel": xlabel,
            "ylabel": ylabel,
            "points": [],
        }

    def record(self, epoch: int, metrics: Dict[str, float]):
        """è®°å½•å½“å‰è½®æ¬¡çš„å¤šä¸ªæŒ‡æ ‡"""
        for key, value in metrics.items():
            if key not in self.lines:
                raise ValueError(f"Metric '{key}' not found. Please use add_line first.")

            line = self.lines[key]
            points = line["points"]

            # é‡‡æ ·é€»è¾‘ï¼šåªä¿ç•™ max_points ä¸ªç‚¹
            if len(points) < self.max_points:
                points.append({"x": epoch, "y": value})
            else:
                # é‡‡æ ·æ›¿æ¢é€»è¾‘ï¼ˆçº¿æ€§å‡åŒ€æ›¿æ¢ï¼‰
                idx = int(epoch / self.total_epochs * self.max_points)
                if 0 <= idx < self.max_points:
                    points[idx] = {"x": epoch, "y": value}

    def update_best(self, epoch: int, metrics: Dict[str, float]):
        """
        æ›´æ–°æœ€ä¼˜ç‚¹ï¼Œä¼šè®°å½•å®Œæ•´çš„ç‚¹ä¿¡æ¯ï¼ˆepoch + metricsï¼‰
        """
        if self.best_point is None or self._is_better(metrics):
            self.best_point = {"epoch": epoch, **metrics}
            self.best_epoch = epoch

    def _is_better(self, metrics: Dict[str, float]) -> bool:
        """å®šä¹‰æœ€ä¼˜åˆ¤æ–­é€»è¾‘ï¼ˆå¯è‡ªå®šä¹‰ï¼‰"""
        if self.best_point is None:
            return True
        # é»˜è®¤æŒ‰ 'loss' æœ€å°å€¼åˆ¤æ–­
        return metrics.get("loss", float("inf")) < self.best_point.get("loss", float("inf"))

    def finalize(self, total_epochs: int):
        """
        åœ¨è®­ç»ƒç»“æŸæ—¶è°ƒç”¨ä»¥è®¾ç½®æ€»è½®æ¬¡ä¾›é‡‡æ ·ç­–ç•¥ä½¿ç”¨
        """
        self.total_epochs = total_epochs
        # æ’å…¥ best_point åˆ°å¯¹åº”ä½ç½®
        if self.best_point and "loss" in self.lines:
            line = self.lines["loss"]
            points = line["points"]
            best_epoch = self.best_point["epoch"]
            if not any(p["x"] == best_epoch for p in points):
                points.append({"x": best_epoch, "y": self.best_point["loss"]})
                points.sort(key=lambda p: p["x"])

    def export_json(self) -> str:
        """
        å¯¼å‡ºä¸º JSON æ ¼å¼ï¼Œå¯ç›´æ¥å­˜å…¥æ•°æ®åº“å­—æ®µ
        åŒ…å«ï¼š
            - å„æ¡æ›²çº¿
            - æœ€ä½³ç‚¹ï¼ˆå¸¦å®Œæ•´ä¿¡æ¯ï¼‰
            - æœ€ä½³è½®æ¬¡
        """
        return json.dumps({
            "lines": self.lines,
            "best_epoch": self.best_epoch,
            "best_point": self.best_point
        }, ensure_ascii=False, indent=2)
```

------

## âœ… ä½¿ç”¨ç¤ºä¾‹

```python
recorder = TrainingRecorder(max_points=1000)
recorder.add_line("loss", title="è®­ç»ƒæŸå¤±", ylabel="Loss")
recorder.add_line("accuracy", title="å‡†ç¡®ç‡", ylabel="Accuracy")

total_epochs = 1000000
for epoch in range(total_epochs):
    # æ¨¡æ‹ŸæŒ‡æ ‡
    loss = 1 / (epoch + 1)
    acc = epoch / total_epochs

    recorder.record(epoch, {"loss": loss, "accuracy": acc})
    recorder.update_best(epoch, {"loss": loss, "accuracy": acc})

# æœ€ç»ˆæ•´ç†ï¼Œç¡®ä¿æ€»è½®æ¬¡ç”Ÿæ•ˆ + æ’å…¥æœ€ä½³ç‚¹
recorder.finalize(total_epochs=total_epochs)

# å¯¼å‡ºç»“æœï¼ˆå¯å­˜å…¥æ•°æ®åº“çš„å•ä¸ªå­—æ®µï¼‰
json_data = recorder.export_json()
```

------

## âœ… å­˜å…¥æ•°æ®åº“å­—æ®µï¼ˆDjangoç¤ºä¾‹ï¼‰

```python
from django.db import models

class TrainingResult(models.Model):
    model_name = models.CharField(max_length=100)
    training_record = models.JSONField()  # å­˜å‚¨ä¸Šé¢ export_json çš„ç»“æœ
```

------

## âœ… ä¼˜åŠ¿

| åŠŸèƒ½               | è¯´æ˜                               |
| ------------------ | ---------------------------------- |
| çº¿æ€§é‡‡æ ·           | è‡ªåŠ¨æ§åˆ¶è®°å½•ç‚¹æ•°ï¼Œæ”¯æŒç™¾ä¸‡è½®æ¬¡è®­ç»ƒ |
| æ’å…¥æœ€ä½³ç‚¹         | å¯ç¡®ä¿æœ€ä½³è½®æ¬¡ä»ä¿ç•™åœ¨æ›²çº¿ä¸Š       |
| å¤šæ¡æ•°æ®çº¿æ”¯æŒ     | æ¯ä¸ªæŒ‡æ ‡éƒ½æœ‰ç‹¬ç«‹é…ç½®å’Œå…ƒä¿¡æ¯       |
| æ•°æ®åº“å‹å¥½         | å…¨éƒ¨ä¿¡æ¯å°è£…ä¸ºä¸€ä¸ª JSON å­—æ®µ       |
| å¯ç›´æ¥ç”¨äºå‰ç«¯ç»˜å›¾ | è¾“å‡ºç»“æ„æ”¯æŒ x/y åæ ‡ã€æ ‡é¢˜ã€æ ‡ç­¾  |

------

å¦‚æœä½ è¿˜éœ€è¦å°†å…¶æ‹†åˆ†ä¸ºæ¨¡å—ã€æ”¯æŒæŒä¹…åŒ–ã€å¢åŠ å‰ç«¯å›¾è¡¨æ ¼å¼åŒ–æ”¯æŒï¼ˆå¦‚ chart.js / echartsï¼‰ï¼Œæˆ‘ä¹Ÿå¯ä»¥ç»§ç»­å¸®ä½ æ‰©å±•ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ

å¥½çš„ï¼Œæˆ‘ä»¬æ¥æ¢³ç†ä½ æå‡ºçš„â€œæœ€ä½³ç‚¹è®°å½•é€»è¾‘â€çš„éœ€æ±‚ï¼Œå¹¶è§£é‡Šå½“å‰å®ç°èƒŒåçš„é€»è¾‘ä»¥åŠå¯èƒ½å‡ºç°çš„â€œè¯¯åˆ¤æœ€ä½³ç‚¹â€çš„åŸå› ã€‚ä½ éœ€è¦çš„æ˜¯ï¼š

------

### âœ… **éœ€æ±‚æ€»ç»“**

1. **è®­ç»ƒè¿‡ç¨‹é‡‡æ ·è®°å½•ï¼ˆç”¨äºç»˜å›¾ï¼‰ï¼š**
   - è‡ªåŠ¨é€‚åº”ä»»æ„è½®æ¬¡æ•°é‡ï¼ˆ100 ~ 10000000ï¼‰ï¼Œæ§åˆ¶é‡‡æ ·é‡ã€‚
   - æ”¯æŒå¤šæ¡è®°å½•çº¿ï¼ˆå¦‚ lossã€val_lossã€accuracy ç­‰ï¼‰ã€‚
   - æ¯æ¡çº¿å¸¦æœ‰ `name`, `title`, `xlabel`, `ylabel` ç­‰å…ƒä¿¡æ¯ã€‚
   - æ‰€æœ‰è®°å½•éƒ½æ˜¯æœ‰åºçš„ï¼ˆæŒ‰è½®æ¬¡é€’å¢ï¼‰ã€‚
2. **è®°å½•â€œæœ€ä½³ç‚¹â€ï¼š**
   - ä»…è®°å½•ä¸€æ¬¡æœ€ä½³ç‚¹ã€‚
   - è¯¥æœ€ä½³ç‚¹æ•°æ®ä¹Ÿéœ€è¦è½å…¥å¯¹åº”çš„ä½ç½®ï¼ˆè½®æ¬¡é¡ºåºä¸­ï¼‰ã€‚
   - æœ€ä½³ç‚¹åº”åŒ…å«å’Œæ™®é€šç‚¹ç›¸åŒçš„å…¨éƒ¨ä¿¡æ¯ã€‚
   - åº”èƒ½æŒ‡å®šå“ªä¸€é¡¹æ˜¯â€œè¯„ä»·æŒ‡æ ‡â€ï¼ˆå¦‚ `val_loss` æœ€å°ã€`accuracy` æœ€å¤§ï¼‰ã€‚
   - æœ€ä½³è½®æ¬¡ä¿¡æ¯è¦å†™å…¥æ•°æ®åº“å­—æ®µï¼ˆå¦‚ `train_record_json`ï¼‰ã€‚

------

### ğŸ§  **å½“å‰æœ€ä½³ç‚¹é€»è¾‘çš„è§£é‡Š**

åœ¨ç›®å‰çš„å®ç°ä¸­ï¼Œâ€œæœ€ä½³ç‚¹â€çš„è¯†åˆ«é€»è¾‘å¯èƒ½æ˜¯è¿™æ ·çš„ï¼ˆä¼ªé€»è¾‘ï¼‰ï¼š

```python
if best_value is None or current_value < best_value:
    best_value = current_value
    best_step = current_step
    best_data = current_data  # è®°å½•è¯¥ç‚¹
```

å› æ­¤åœ¨**è®­ç»ƒæ—©æœŸ**ï¼Œä¾‹å¦‚ç¬¬ 1ã€2ã€3 æ­¥ï¼Œåªè¦ `current_value` æ¯” `best_value` å°ï¼Œå°±ä¼šè¢«è®¤ä¸ºæ˜¯â€œæœ€ä½³ç‚¹â€ï¼Œå³ä¾¿å®ƒåªæ˜¯æš‚æ—¶å¥½ä¸€ç‚¹ã€‚

------

### â—ï¸æ½œåœ¨é—®é¢˜

- **å¤šæ¬¡æ›´æ–°æœ€ä½³ç‚¹**ï¼šæ¯æ¬¡å‘ç°æ›´ä¼˜çš„æŒ‡æ ‡å°±æ›´æ–°ï¼Œå¯¼è‡´å‰æœŸé¢‘ç¹è®°å½•â€œæœ€ä½³ç‚¹â€ã€‚
- **ç»“æœâ€œæ¼‚ç§»â€æˆ–ä¸ç¨³å®š**ï¼šå¦‚æœæ—©æœŸæ•°æ®æ³¢åŠ¨å¤§ï¼Œå¯èƒ½è¯¯è®°å½•å¾ˆå¤šâ€œæ¬¡ä¼˜ç‚¹â€ã€‚

------

### âœ… **æ›´ç¨³å¥çš„â€œæœ€ä½³ç‚¹è®°å½•é€»è¾‘â€å»ºè®®**

ä½ å¯ä»¥é€‰æ‹©ï¼š

#### âœ… æ–¹æ³•ä¸€ï¼š**åªè®°å½•æœ€ç»ˆæœ€ä½³ç‚¹**

é€‚åˆè®­ç»ƒç»“æŸåè®°å½•ï¼Œä¾‹å¦‚ï¼š

```python
# åœ¨è®­ç»ƒå®Œæˆåè¿›è¡Œæ¯”è¾ƒä¸è®°å½•
final_best_step = np.argmin(val_loss_list)  # or argmax for accuracy
final_best_data = full_record[final_best_step]
```

ä¼˜ç‚¹ï¼š

- é¿å…å‰æœŸæ³¢åŠ¨å½±å“ã€‚
- ç®€æ´ã€åªå†™å…¥ä¸€æ¬¡ã€‚

------

#### âœ… æ–¹æ³•äºŒï¼š**å®æ—¶è®°å½•ä½†åªä¿å­˜ä¸€æ¬¡**

é€‚åˆå¸Œæœ›å®æ—¶è¿½è¸ªæœ€ä¼˜æ¨¡å‹çš„åŒæ—¶ï¼Œ**ä»…è®°å½•ä¸€æ¡æœ€ä½³è®°å½•æ•°æ®**ï¼š

```python
# åˆå§‹åŒ–
best_value = float('inf')
best_record = None
best_step = None

# æ¯è½®è®­ç»ƒä¸­
if metric_value < best_value:
    best_value = metric_value
    best_step = current_step
    best_record = current_metrics.copy()
```

> **æ³¨æ„**ï¼šè¿™ä¸ª `best_record` æœ€ç»ˆåªä¿å­˜ä¸€æ¬¡ï¼ŒåŠ å…¥å®Œæ•´è®°å½•åˆ—è¡¨æ—¶æ’å…¥åˆ°å¯¹åº”è½®æ¬¡é¡ºåºä¸­ã€‚

------

### âœ… å¦‚ä½•â€œæ’å…¥æœ€ä½³ç‚¹åˆ°è®°å½•åˆ—è¡¨ä¸­æ­£ç¡®ä½ç½®â€ï¼Ÿ

ä¾‹å¦‚ï¼Œè®­ç»ƒè®°å½•åˆ—è¡¨å¦‚ä¸‹ï¼š

```python
records = [
    {"step": 1, "val_loss": 0.95},
    {"step": 2, "val_loss": 0.93},
    {"step": 5, "val_loss": 0.90},
]
best = {"step": 2, "val_loss": 0.93, "is_best": True}
```

ä½ å¯ä»¥åœ¨ä¿å­˜å‰åšå¦‚ä¸‹æ’å…¥ï¼š

```python
inserted = False
for i, r in enumerate(records):
    if r["step"] > best["step"]:
        records.insert(i, best)
        inserted = True
        break

if not inserted:
    records.append(best)
```

------

### âœ… ç¤ºä¾‹è®°å½•ç»“æ„ï¼ˆæ”¯æŒå¤šæ¡çº¿ã€ç»˜å›¾ä¿¡æ¯ï¼‰

```json
{
  "title": "è®­ç»ƒè¿‡ç¨‹è®°å½•",
  "xlabel": "è½®æ¬¡",
  "ylabel": "æŒ‡æ ‡å€¼",
  "best_step": 42,
  "lines": [
    {
      "name": "loss",
      "label": "è®­ç»ƒæŸå¤±",
      "color": "#ff0000",
      "points": [[1, 0.9], [2, 0.85], ..., [42, 0.12]]
    },
    {
      "name": "val_loss",
      "label": "éªŒè¯æŸå¤±",
      "color": "#0000ff",
      "points": [[1, 1.0], [2, 0.95], ..., [42, 0.11]]
    }
  ]
}
```

ä½ å¯ä»¥å°†è¿™ä¸ª JSON å­˜å…¥æ•°æ®åº“ä¸­çš„ä¸€ä¸ª `TextField` æˆ– `JSONField` å­—æ®µï¼Œå­—æ®µåå¦‚ï¼š`train_record_json`ã€‚

------

å¦‚æœä½ æƒ³è¦æˆ‘å¸®ä½ å®Œå–„ä»£ç ï¼Œè‡ªåŠ¨é‡‡æ ·ã€è®°å½•ã€å¤„ç†æœ€ä½³ç‚¹å¹¶ç”Ÿæˆè¿™ç§ç»“æ„ï¼Œè¯·å‘Šè¯‰æˆ‘ä½ ç”¨çš„æ˜¯å“ªç§æ¡†æ¶ï¼ˆPyTorch / Keras / è‡ªå®šä¹‰è®­ç»ƒé€»è¾‘ï¼‰ï¼Œæˆ‘å¯ä»¥æä¾›æ•´å¥—å°è£…ã€‚
